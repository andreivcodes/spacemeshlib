/* eslint-disable */
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Empty } from "../../google/protobuf/empty";
import {
  CoinbaseResponse,
  EstimatedRewardsRequest,
  EstimatedRewardsResponse,
  IsSmeshingResponse,
  MinGasResponse,
  PostConfigResponse,
  PostSetupComputeProvidersRequest,
  PostSetupComputeProvidersResponse,
  PostSetupStatusResponse,
  PostSetupStatusStreamResponse,
  SetCoinbaseRequest,
  SetCoinbaseResponse,
  SetMinGasRequest,
  SetMinGasResponse,
  SmesherIDResponse,
  StartSmeshingRequest,
  StartSmeshingResponse,
  StopSmeshingRequest,
  StopSmeshingResponse,
} from "./smesher_types";

export const protobufPackage = "spacemesh.v1";

export interface SmesherService {
  /** Returns true iff node is currently smeshing */
  IsSmeshing(request: Empty): Promise<IsSmeshingResponse>;
  /**
   * Starts smeshing, after completing the post setup.
   * Changing of the post setup options (e.g., number of units), after initial setup, is supported.
   * Returns success if request is accepted by node , failure if it fails
   */
  StartSmeshing(request: StartSmeshingRequest): Promise<StartSmeshingResponse>;
  /**
   * Stops smeshing, or the preceding post setup session, and optionally attempt to
   * delete the post setup data files(s).
   * Returns success if request is accepted by node, failure if it fails
   */
  StopSmeshing(request: StopSmeshingRequest): Promise<StopSmeshingResponse>;
  /** Get the current smesher id generated by the node */
  SmesherID(request: Empty): Promise<SmesherIDResponse>;
  /** Get the current coinbase */
  Coinbase(request: Empty): Promise<CoinbaseResponse>;
  /**
   * Set the coinbase
   * Returns success if request succeeds, failure if it fails
   */
  SetCoinbase(request: SetCoinbaseRequest): Promise<SetCoinbaseResponse>;
  /** Get the current min gas for including txs in blocks by this smesher */
  MinGas(request: Empty): Promise<MinGasResponse>;
  /**
   * Set a min gas units for including txs in blocks by this smesher
   * Returns success if request succeeds, failure if it fails
   */
  SetMinGas(request: SetMinGasRequest): Promise<SetMinGasResponse>;
  /** Estimate smeshing rewards over the next upcoming epoch */
  EstimatedRewards(request: EstimatedRewardsRequest): Promise<EstimatedRewardsResponse>;
  /** Returns the Post setup status */
  PostSetupStatus(request: Empty): Promise<PostSetupStatusResponse>;
  /** Returns a stream of updates for the Post setup status */
  PostSetupStatusStream(request: Empty): Observable<PostSetupStatusStreamResponse>;
  /** Returns a list of available Post setup compute providers */
  PostSetupComputeProviders(request: PostSetupComputeProvidersRequest): Promise<PostSetupComputeProvidersResponse>;
  /** Returns the Post protocol config */
  PostConfig(request: Empty): Promise<PostConfigResponse>;
}

export class SmesherServiceClientImpl implements SmesherService {
  private readonly rpc: Rpc;
  constructor(rpc: Rpc) {
    this.rpc = rpc;
    this.IsSmeshing = this.IsSmeshing.bind(this);
    this.StartSmeshing = this.StartSmeshing.bind(this);
    this.StopSmeshing = this.StopSmeshing.bind(this);
    this.SmesherID = this.SmesherID.bind(this);
    this.Coinbase = this.Coinbase.bind(this);
    this.SetCoinbase = this.SetCoinbase.bind(this);
    this.MinGas = this.MinGas.bind(this);
    this.SetMinGas = this.SetMinGas.bind(this);
    this.EstimatedRewards = this.EstimatedRewards.bind(this);
    this.PostSetupStatus = this.PostSetupStatus.bind(this);
    this.PostSetupStatusStream = this.PostSetupStatusStream.bind(this);
    this.PostSetupComputeProviders = this.PostSetupComputeProviders.bind(this);
    this.PostConfig = this.PostConfig.bind(this);
  }
  IsSmeshing(request: Empty): Promise<IsSmeshingResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "IsSmeshing", data);
    return promise.then((data) => IsSmeshingResponse.decode(new _m0.Reader(data)));
  }

  StartSmeshing(request: StartSmeshingRequest): Promise<StartSmeshingResponse> {
    const data = StartSmeshingRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "StartSmeshing", data);
    return promise.then((data) => StartSmeshingResponse.decode(new _m0.Reader(data)));
  }

  StopSmeshing(request: StopSmeshingRequest): Promise<StopSmeshingResponse> {
    const data = StopSmeshingRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "StopSmeshing", data);
    return promise.then((data) => StopSmeshingResponse.decode(new _m0.Reader(data)));
  }

  SmesherID(request: Empty): Promise<SmesherIDResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "SmesherID", data);
    return promise.then((data) => SmesherIDResponse.decode(new _m0.Reader(data)));
  }

  Coinbase(request: Empty): Promise<CoinbaseResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "Coinbase", data);
    return promise.then((data) => CoinbaseResponse.decode(new _m0.Reader(data)));
  }

  SetCoinbase(request: SetCoinbaseRequest): Promise<SetCoinbaseResponse> {
    const data = SetCoinbaseRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "SetCoinbase", data);
    return promise.then((data) => SetCoinbaseResponse.decode(new _m0.Reader(data)));
  }

  MinGas(request: Empty): Promise<MinGasResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "MinGas", data);
    return promise.then((data) => MinGasResponse.decode(new _m0.Reader(data)));
  }

  SetMinGas(request: SetMinGasRequest): Promise<SetMinGasResponse> {
    const data = SetMinGasRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "SetMinGas", data);
    return promise.then((data) => SetMinGasResponse.decode(new _m0.Reader(data)));
  }

  EstimatedRewards(request: EstimatedRewardsRequest): Promise<EstimatedRewardsResponse> {
    const data = EstimatedRewardsRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "EstimatedRewards", data);
    return promise.then((data) => EstimatedRewardsResponse.decode(new _m0.Reader(data)));
  }

  PostSetupStatus(request: Empty): Promise<PostSetupStatusResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "PostSetupStatus", data);
    return promise.then((data) => PostSetupStatusResponse.decode(new _m0.Reader(data)));
  }

  PostSetupStatusStream(request: Empty): Observable<PostSetupStatusStreamResponse> {
    const data = Empty.encode(request).finish();
    const result = this.rpc.serverStreamingRequest("spacemesh.v1.SmesherService", "PostSetupStatusStream", data);
    return result.pipe(map((data) => PostSetupStatusStreamResponse.decode(new _m0.Reader(data))));
  }

  PostSetupComputeProviders(request: PostSetupComputeProvidersRequest): Promise<PostSetupComputeProvidersResponse> {
    const data = PostSetupComputeProvidersRequest.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "PostSetupComputeProviders", data);
    return promise.then((data) => PostSetupComputeProvidersResponse.decode(new _m0.Reader(data)));
  }

  PostConfig(request: Empty): Promise<PostConfigResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request("spacemesh.v1.SmesherService", "PostConfig", data);
    return promise.then((data) => PostConfigResponse.decode(new _m0.Reader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}
