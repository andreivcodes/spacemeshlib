// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/types.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message spacemesh.v1.SimpleInt
 */
export interface SimpleInt {
    /**
     * @generated from protobuf field: uint64 value = 1;
     */
    value: bigint;
}
/**
 * @generated from protobuf message spacemesh.v1.SimpleString
 */
export interface SimpleString {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
}
/**
 * A non-negative coin amount, in smidge
 *
 * @generated from protobuf message spacemesh.v1.Amount
 */
export interface Amount {
    /**
     * @generated from protobuf field: uint64 value = 1;
     */
    value: bigint;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountId
 */
export interface AccountId {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionId
 */
export interface TransactionId {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
}
/**
 * @generated from protobuf message spacemesh.v1.ActivationId
 */
export interface ActivationId {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherId
 */
export interface SmesherId {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
}
/**
 * An Activation "transaction" (ATX)
 *
 * @generated from protobuf message spacemesh.v1.Activation
 */
export interface Activation {
    /**
     * @generated from protobuf field: spacemesh.v1.ActivationId id = 1;
     */
    id?: ActivationId;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer = 2;
     */
    layer?: LayerNumber; // the layer that this activation is part of
    /**
     * @generated from protobuf field: spacemesh.v1.SmesherId smesher_id = 3;
     */
    smesherId?: SmesherId; // id of smesher who created the ATX
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId coinbase = 4;
     */
    coinbase?: AccountId; // coinbase account id
    /**
     * @generated from protobuf field: spacemesh.v1.ActivationId prev_atx = 5;
     */
    prevAtx?: ActivationId; // previous ATX pointed to
    /**
     * @generated from protobuf field: uint32 num_units = 6;
     */
    numUnits: number; // number of PoST data commitment units
}
/**
 * An immutable Spacemesh transaction.
 * do not include mutable data such as tx state or result.
 *
 * @generated from protobuf message spacemesh.v1.Transaction
 */
export interface Transaction {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId principal = 2;
     */
    principal?: AccountId;
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId template = 3;
     */
    template?: AccountId;
    /**
     * @generated from protobuf field: uint32 method = 4;
     */
    method: number; // this is actually limited by uint8, but no type for that.
    /**
     * @generated from protobuf field: spacemesh.v1.Nonce nonce = 5;
     */
    nonce?: Nonce;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerLimits limits = 6;
     */
    limits?: LayerLimits;
    /**
     * @generated from protobuf field: uint64 max_gas = 7;
     */
    maxGas: bigint;
    /**
     * @generated from protobuf field: uint64 gas_price = 8;
     */
    gasPrice: bigint;
    /**
     * @generated from protobuf field: uint64 max_spend = 9;
     */
    maxSpend: bigint;
    /**
     * @generated from protobuf field: bytes raw = 10;
     */
    raw: Uint8Array;
}
/**
 * @generated from protobuf message spacemesh.v1.LayerLimits
 */
export interface LayerLimits {
    /**
     * @generated from protobuf field: uint32 min = 1;
     */
    min: number;
    /**
     * @generated from protobuf field: uint32 max = 2;
     */
    max: number;
}
/**
 * @generated from protobuf message spacemesh.v1.Nonce
 */
export interface Nonce {
    /**
     * @generated from protobuf field: uint64 counter = 1;
     */
    counter: bigint;
    /**
     * @generated from protobuf field: uint32 bitfield = 2;
     */
    bitfield: number; // this is actually limited by uint8, but no type for that.
}
/**
 * Transaction that was added to the mesh.
 *
 * @generated from protobuf message spacemesh.v1.MeshTransaction
 */
export interface MeshTransaction {
    /**
     * @generated from protobuf field: spacemesh.v1.Transaction transaction = 1;
     */
    transaction?: Transaction;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer_id = 2;
     */
    layerId?: LayerNumber;
}
/**
 * @generated from protobuf message spacemesh.v1.Reward
 */
export interface Reward {
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer = 1;
     */
    layer?: LayerNumber; // layer award was paid in
    /**
     * @generated from protobuf field: spacemesh.v1.Amount total = 2;
     */
    total?: Amount; // total reward paid (sum of tx fee and layer reward)
    /**
     * @generated from protobuf field: spacemesh.v1.Amount layer_reward = 3;
     */
    layerReward?: Amount; // tx_fee = total - layer_reward
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer_computed = 4;
     */
    layerComputed?: LayerNumber; // layer number of the layer when reward was computed
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId coinbase = 5;
     */
    coinbase?: AccountId; // account awarded this reward
    /**
     * @generated from protobuf field: spacemesh.v1.SmesherId smesher = 6;
     */
    smesher?: SmesherId; // id of smesher who earned this reward
}
/**
 * @generated from protobuf message spacemesh.v1.Block
 */
export interface Block {
    /**
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array; // block hash
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Transaction transactions = 2;
     */
    transactions: Transaction[]; // block transactions
    /**
     * @generated from protobuf field: spacemesh.v1.ActivationId activation_id = 3;
     */
    activationId?: ActivationId; // the smesher's activation that this block refers to
    /**
     * @generated from protobuf field: spacemesh.v1.SmesherId smesher_id = 4;
     */
    smesherId?: SmesherId; // the id of the smesher who submitted this block
}
/**
 * @generated from protobuf message spacemesh.v1.Layer
 */
export interface Layer {
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber number = 1;
     */
    number?: LayerNumber; // layer number - not hash - layer content may change
    /**
     * @generated from protobuf field: spacemesh.v1.Layer.LayerStatus status = 2;
     */
    status: Layer_LayerStatus;
    /**
     * @generated from protobuf field: bytes hash = 3;
     */
    hash: Uint8Array; // computer layer hash - do we need this?
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Block blocks = 4;
     */
    blocks: Block[]; // layer's blocks
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Activation activations = 5;
     */
    activations: Activation[]; // list of layer's activations
    /**
     * @generated from protobuf field: bytes root_state_hash = 6;
     */
    rootStateHash: Uint8Array; // when available - the root state hash of global state in this layer
}
/**
 * @generated from protobuf enum spacemesh.v1.Layer.LayerStatus
 */
export enum Layer_LayerStatus {
    /**
     * not yet approved or confirmed
     *
     * @generated from protobuf enum value: LAYER_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * approved by hare
     *
     * @generated from protobuf enum value: LAYER_STATUS_APPROVED = 1;
     */
    APPROVED = 1,
    /**
     * confirmed by tortoise
     *
     * @generated from protobuf enum value: LAYER_STATUS_CONFIRMED = 2;
     */
    CONFIRMED = 2,
    /**
     * applied in state
     *
     * @generated from protobuf enum value: LAYER_STATUS_APPLIED = 3;
     */
    APPLIED = 3
}
/**
 * @generated from protobuf message spacemesh.v1.LayerNumber
 */
export interface LayerNumber {
    /**
     * @generated from protobuf field: uint32 number = 1;
     */
    number: number;
}
/**
 * an event emitted from an app instance
 *
 * @generated from protobuf message spacemesh.v1.AppEvent
 */
export interface AppEvent {
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionId transaction_id = 1;
     */
    transactionId?: TransactionId; // the transaction that called the code
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string; // the event's string emitted from code
}
// @generated message type with reflection information, may provide speed optimized methods
class SimpleInt$Type extends MessageType<SimpleInt> {
    constructor() {
        super("spacemesh.v1.SimpleInt", [
            { no: 1, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleInt>): SimpleInt {
        const message = { value: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleInt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleInt): SimpleInt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 value */ 1:
                    message.value = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleInt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SimpleInt
 */
export const SimpleInt = new SimpleInt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleString$Type extends MessageType<SimpleString> {
    constructor() {
        super("spacemesh.v1.SimpleString", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleString>): SimpleString {
        const message = { value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleString>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleString): SimpleString {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleString, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SimpleString
 */
export const SimpleString = new SimpleString$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Amount$Type extends MessageType<Amount> {
    constructor() {
        super("spacemesh.v1.Amount", [
            { no: 1, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Amount>): Amount {
        const message = { value: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Amount>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Amount): Amount {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 value */ 1:
                    message.value = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Amount, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 value = 1; */
        if (message.value !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Amount
 */
export const Amount = new Amount$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountId$Type extends MessageType<AccountId> {
    constructor() {
        super("spacemesh.v1.AccountId", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountId>): AccountId {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountId): AccountId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountId
 */
export const AccountId = new AccountId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionId$Type extends MessageType<TransactionId> {
    constructor() {
        super("spacemesh.v1.TransactionId", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionId>): TransactionId {
        const message = { id: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionId): TransactionId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionId
 */
export const TransactionId = new TransactionId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActivationId$Type extends MessageType<ActivationId> {
    constructor() {
        super("spacemesh.v1.ActivationId", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ActivationId>): ActivationId {
        const message = { id: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActivationId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActivationId): ActivationId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActivationId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.ActivationId
 */
export const ActivationId = new ActivationId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherId$Type extends MessageType<SmesherId> {
    constructor() {
        super("spacemesh.v1.SmesherId", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SmesherId>): SmesherId {
        const message = { id: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherId): SmesherId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherId
 */
export const SmesherId = new SmesherId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Activation$Type extends MessageType<Activation> {
    constructor() {
        super("spacemesh.v1.Activation", [
            { no: 1, name: "id", kind: "message", T: () => ActivationId },
            { no: 2, name: "layer", kind: "message", T: () => LayerNumber },
            { no: 3, name: "smesher_id", kind: "message", T: () => SmesherId },
            { no: 4, name: "coinbase", kind: "message", T: () => AccountId },
            { no: 5, name: "prev_atx", kind: "message", T: () => ActivationId },
            { no: 6, name: "num_units", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Activation>): Activation {
        const message = { numUnits: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Activation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Activation): Activation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.ActivationId id */ 1:
                    message.id = ActivationId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* spacemesh.v1.LayerNumber layer */ 2:
                    message.layer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layer);
                    break;
                case /* spacemesh.v1.SmesherId smesher_id */ 3:
                    message.smesherId = SmesherId.internalBinaryRead(reader, reader.uint32(), options, message.smesherId);
                    break;
                case /* spacemesh.v1.AccountId coinbase */ 4:
                    message.coinbase = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.coinbase);
                    break;
                case /* spacemesh.v1.ActivationId prev_atx */ 5:
                    message.prevAtx = ActivationId.internalBinaryRead(reader, reader.uint32(), options, message.prevAtx);
                    break;
                case /* uint32 num_units */ 6:
                    message.numUnits = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Activation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.ActivationId id = 1; */
        if (message.id)
            ActivationId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber layer = 2; */
        if (message.layer)
            LayerNumber.internalBinaryWrite(message.layer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.SmesherId smesher_id = 3; */
        if (message.smesherId)
            SmesherId.internalBinaryWrite(message.smesherId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.AccountId coinbase = 4; */
        if (message.coinbase)
            AccountId.internalBinaryWrite(message.coinbase, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.ActivationId prev_atx = 5; */
        if (message.prevAtx)
            ActivationId.internalBinaryWrite(message.prevAtx, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 num_units = 6; */
        if (message.numUnits !== 0)
            writer.tag(6, WireType.Varint).uint32(message.numUnits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Activation
 */
export const Activation = new Activation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("spacemesh.v1.Transaction", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "principal", kind: "message", T: () => AccountId },
            { no: 3, name: "template", kind: "message", T: () => AccountId },
            { no: 4, name: "method", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "nonce", kind: "message", T: () => Nonce },
            { no: 6, name: "limits", kind: "message", T: () => LayerLimits },
            { no: 7, name: "max_gas", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "gas_price", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "max_spend", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "raw", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { id: new Uint8Array(0), method: 0, maxGas: 0n, gasPrice: 0n, maxSpend: 0n, raw: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* spacemesh.v1.AccountId principal */ 2:
                    message.principal = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.principal);
                    break;
                case /* spacemesh.v1.AccountId template */ 3:
                    message.template = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.template);
                    break;
                case /* uint32 method */ 4:
                    message.method = reader.uint32();
                    break;
                case /* spacemesh.v1.Nonce nonce */ 5:
                    message.nonce = Nonce.internalBinaryRead(reader, reader.uint32(), options, message.nonce);
                    break;
                case /* spacemesh.v1.LayerLimits limits */ 6:
                    message.limits = LayerLimits.internalBinaryRead(reader, reader.uint32(), options, message.limits);
                    break;
                case /* uint64 max_gas */ 7:
                    message.maxGas = reader.uint64().toBigInt();
                    break;
                case /* uint64 gas_price */ 8:
                    message.gasPrice = reader.uint64().toBigInt();
                    break;
                case /* uint64 max_spend */ 9:
                    message.maxSpend = reader.uint64().toBigInt();
                    break;
                case /* bytes raw */ 10:
                    message.raw = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* spacemesh.v1.AccountId principal = 2; */
        if (message.principal)
            AccountId.internalBinaryWrite(message.principal, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.AccountId template = 3; */
        if (message.template)
            AccountId.internalBinaryWrite(message.template, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 method = 4; */
        if (message.method !== 0)
            writer.tag(4, WireType.Varint).uint32(message.method);
        /* spacemesh.v1.Nonce nonce = 5; */
        if (message.nonce)
            Nonce.internalBinaryWrite(message.nonce, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerLimits limits = 6; */
        if (message.limits)
            LayerLimits.internalBinaryWrite(message.limits, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint64 max_gas = 7; */
        if (message.maxGas !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.maxGas);
        /* uint64 gas_price = 8; */
        if (message.gasPrice !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.gasPrice);
        /* uint64 max_spend = 9; */
        if (message.maxSpend !== 0n)
            writer.tag(9, WireType.Varint).uint64(message.maxSpend);
        /* bytes raw = 10; */
        if (message.raw.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.raw);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerLimits$Type extends MessageType<LayerLimits> {
    constructor() {
        super("spacemesh.v1.LayerLimits", [
            { no: 1, name: "min", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "max", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LayerLimits>): LayerLimits {
        const message = { min: 0, max: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerLimits>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerLimits): LayerLimits {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 min */ 1:
                    message.min = reader.uint32();
                    break;
                case /* uint32 max */ 2:
                    message.max = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayerLimits, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 min = 1; */
        if (message.min !== 0)
            writer.tag(1, WireType.Varint).uint32(message.min);
        /* uint32 max = 2; */
        if (message.max !== 0)
            writer.tag(2, WireType.Varint).uint32(message.max);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerLimits
 */
export const LayerLimits = new LayerLimits$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Nonce$Type extends MessageType<Nonce> {
    constructor() {
        super("spacemesh.v1.Nonce", [
            { no: 1, name: "counter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "bitfield", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Nonce>): Nonce {
        const message = { counter: 0n, bitfield: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Nonce>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Nonce): Nonce {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 counter */ 1:
                    message.counter = reader.uint64().toBigInt();
                    break;
                case /* uint32 bitfield */ 2:
                    message.bitfield = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Nonce, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 counter = 1; */
        if (message.counter !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.counter);
        /* uint32 bitfield = 2; */
        if (message.bitfield !== 0)
            writer.tag(2, WireType.Varint).uint32(message.bitfield);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Nonce
 */
export const Nonce = new Nonce$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MeshTransaction$Type extends MessageType<MeshTransaction> {
    constructor() {
        super("spacemesh.v1.MeshTransaction", [
            { no: 1, name: "transaction", kind: "message", T: () => Transaction },
            { no: 2, name: "layer_id", kind: "message", T: () => LayerNumber }
        ]);
    }
    create(value?: PartialMessage<MeshTransaction>): MeshTransaction {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MeshTransaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MeshTransaction): MeshTransaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                case /* spacemesh.v1.LayerNumber layer_id */ 2:
                    message.layerId = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layerId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MeshTransaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber layer_id = 2; */
        if (message.layerId)
            LayerNumber.internalBinaryWrite(message.layerId, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.MeshTransaction
 */
export const MeshTransaction = new MeshTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Reward$Type extends MessageType<Reward> {
    constructor() {
        super("spacemesh.v1.Reward", [
            { no: 1, name: "layer", kind: "message", T: () => LayerNumber },
            { no: 2, name: "total", kind: "message", T: () => Amount },
            { no: 3, name: "layer_reward", kind: "message", T: () => Amount },
            { no: 4, name: "layer_computed", kind: "message", T: () => LayerNumber },
            { no: 5, name: "coinbase", kind: "message", T: () => AccountId },
            { no: 6, name: "smesher", kind: "message", T: () => SmesherId }
        ]);
    }
    create(value?: PartialMessage<Reward>): Reward {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Reward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reward): Reward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.LayerNumber layer */ 1:
                    message.layer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layer);
                    break;
                case /* spacemesh.v1.Amount total */ 2:
                    message.total = Amount.internalBinaryRead(reader, reader.uint32(), options, message.total);
                    break;
                case /* spacemesh.v1.Amount layer_reward */ 3:
                    message.layerReward = Amount.internalBinaryRead(reader, reader.uint32(), options, message.layerReward);
                    break;
                case /* spacemesh.v1.LayerNumber layer_computed */ 4:
                    message.layerComputed = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layerComputed);
                    break;
                case /* spacemesh.v1.AccountId coinbase */ 5:
                    message.coinbase = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.coinbase);
                    break;
                case /* spacemesh.v1.SmesherId smesher */ 6:
                    message.smesher = SmesherId.internalBinaryRead(reader, reader.uint32(), options, message.smesher);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.LayerNumber layer = 1; */
        if (message.layer)
            LayerNumber.internalBinaryWrite(message.layer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Amount total = 2; */
        if (message.total)
            Amount.internalBinaryWrite(message.total, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Amount layer_reward = 3; */
        if (message.layerReward)
            Amount.internalBinaryWrite(message.layerReward, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber layer_computed = 4; */
        if (message.layerComputed)
            LayerNumber.internalBinaryWrite(message.layerComputed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.AccountId coinbase = 5; */
        if (message.coinbase)
            AccountId.internalBinaryWrite(message.coinbase, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.SmesherId smesher = 6; */
        if (message.smesher)
            SmesherId.internalBinaryWrite(message.smesher, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Reward
 */
export const Reward = new Reward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Block$Type extends MessageType<Block> {
    constructor() {
        super("spacemesh.v1.Block", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction },
            { no: 3, name: "activation_id", kind: "message", T: () => ActivationId },
            { no: 4, name: "smesher_id", kind: "message", T: () => SmesherId }
        ]);
    }
    create(value?: PartialMessage<Block>): Block {
        const message = { id: new Uint8Array(0), transactions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Block>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Block): Block {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* repeated spacemesh.v1.Transaction transactions */ 2:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* spacemesh.v1.ActivationId activation_id */ 3:
                    message.activationId = ActivationId.internalBinaryRead(reader, reader.uint32(), options, message.activationId);
                    break;
                case /* spacemesh.v1.SmesherId smesher_id */ 4:
                    message.smesherId = SmesherId.internalBinaryRead(reader, reader.uint32(), options, message.smesherId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Block, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* repeated spacemesh.v1.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.ActivationId activation_id = 3; */
        if (message.activationId)
            ActivationId.internalBinaryWrite(message.activationId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.SmesherId smesher_id = 4; */
        if (message.smesherId)
            SmesherId.internalBinaryWrite(message.smesherId, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Block
 */
export const Block = new Block$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Layer$Type extends MessageType<Layer> {
    constructor() {
        super("spacemesh.v1.Layer", [
            { no: 1, name: "number", kind: "message", T: () => LayerNumber },
            { no: 2, name: "status", kind: "enum", T: () => ["spacemesh.v1.Layer.LayerStatus", Layer_LayerStatus, "LAYER_STATUS_"] },
            { no: 3, name: "hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "blocks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Block },
            { no: 5, name: "activations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Activation },
            { no: 6, name: "root_state_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Layer>): Layer {
        const message = { status: 0, hash: new Uint8Array(0), blocks: [], activations: [], rootStateHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Layer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Layer): Layer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.LayerNumber number */ 1:
                    message.number = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.number);
                    break;
                case /* spacemesh.v1.Layer.LayerStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* bytes hash */ 3:
                    message.hash = reader.bytes();
                    break;
                case /* repeated spacemesh.v1.Block blocks */ 4:
                    message.blocks.push(Block.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated spacemesh.v1.Activation activations */ 5:
                    message.activations.push(Activation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bytes root_state_hash */ 6:
                    message.rootStateHash = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Layer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.LayerNumber number = 1; */
        if (message.number)
            LayerNumber.internalBinaryWrite(message.number, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Layer.LayerStatus status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* bytes hash = 3; */
        if (message.hash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hash);
        /* repeated spacemesh.v1.Block blocks = 4; */
        for (let i = 0; i < message.blocks.length; i++)
            Block.internalBinaryWrite(message.blocks[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated spacemesh.v1.Activation activations = 5; */
        for (let i = 0; i < message.activations.length; i++)
            Activation.internalBinaryWrite(message.activations[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bytes root_state_hash = 6; */
        if (message.rootStateHash.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.rootStateHash);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Layer
 */
export const Layer = new Layer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerNumber$Type extends MessageType<LayerNumber> {
    constructor() {
        super("spacemesh.v1.LayerNumber", [
            { no: 1, name: "number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<LayerNumber>): LayerNumber {
        const message = { number: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerNumber>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerNumber): LayerNumber {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 number */ 1:
                    message.number = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayerNumber, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 number = 1; */
        if (message.number !== 0)
            writer.tag(1, WireType.Varint).uint32(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerNumber
 */
export const LayerNumber = new LayerNumber$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEvent$Type extends MessageType<AppEvent> {
    constructor() {
        super("spacemesh.v1.AppEvent", [
            { no: 1, name: "transaction_id", kind: "message", T: () => TransactionId },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AppEvent>): AppEvent {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEvent): AppEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.TransactionId transaction_id */ 1:
                    message.transactionId = TransactionId.internalBinaryRead(reader, reader.uint32(), options, message.transactionId);
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.TransactionId transaction_id = 1; */
        if (message.transactionId)
            TransactionId.internalBinaryWrite(message.transactionId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AppEvent
 */
export const AppEvent = new AppEvent$Type();
