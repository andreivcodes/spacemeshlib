// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/tx_types.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Transaction } from "./types";
import { Status } from "../../google/rpc/status";
import { TransactionId } from "./types";
/**
 * @generated from protobuf message spacemesh.v1.TransactionsIds
 */
export interface TransactionsIds {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.TransactionId transaction_id = 1;
     */
    transactionId: TransactionId[];
}
/**
 * @generated from protobuf message spacemesh.v1.SubmitTransactionRequest
 */
export interface SubmitTransactionRequest {
    /**
     * @generated from protobuf field: bytes transaction = 1;
     */
    transaction: Uint8Array; // signed binary transaction
}
/**
 * @generated from protobuf message spacemesh.v1.SubmitTransactionResponse
 */
export interface SubmitTransactionResponse {
    /**
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionState txstate = 2;
     */
    txstate?: TransactionState;
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionsStateRequest
 */
export interface TransactionsStateRequest {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.TransactionId transaction_id = 1;
     */
    transactionId: TransactionId[];
    /**
     * @generated from protobuf field: bool include_transactions = 2;
     */
    includeTransactions: boolean; // when true response will include matching transactions in addition to state
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionsStateResponse
 */
export interface TransactionsStateResponse {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.TransactionState transactions_state = 1;
     */
    transactionsState: TransactionState[];
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Transaction transactions = 2;
     */
    transactions: Transaction[];
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionsStateStreamRequest
 */
export interface TransactionsStateStreamRequest {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.TransactionId transaction_id = 1;
     */
    transactionId: TransactionId[];
    /**
     * @generated from protobuf field: bool include_transactions = 2;
     */
    includeTransactions: boolean; // when true response will include matching transactions in addition to state
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionsStateStreamResponse
 */
export interface TransactionsStateStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionState transaction_state = 1;
     */
    transactionState?: TransactionState;
    /**
     * @generated from protobuf field: spacemesh.v1.Transaction transaction = 2;
     */
    transaction?: Transaction;
}
/**
 * TransactionState is the "journey" of a tx from mempool to block inclusion to
 * mesh to STF processing. To know whether or not the tx actually succeeded,
 * and its side effects, check the Receipt in the GlobalStateService.
 *
 * @generated from protobuf message spacemesh.v1.TransactionState
 */
export interface TransactionState {
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionId id = 1;
     */
    id?: TransactionId;
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionState.TransactionState state = 2;
     */
    state: TransactionState_TransactionState;
}
/**
 * @generated from protobuf enum spacemesh.v1.TransactionState.TransactionState
 */
export enum TransactionState_TransactionState {
    /**
     * default state
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * rejected from mempool due to, e.g., invalid syntax
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_REJECTED = 1;
     */
    REJECTED = 1,
    /**
     * rejected from mempool by funds check
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_INSUFFICIENT_FUNDS = 2;
     */
    INSUFFICIENT_FUNDS = 2,
    /**
     * rejected from mempool due to conflicting counter
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_CONFLICTING = 3;
     */
    CONFLICTING = 3,
    /**
     * in mempool but not on the mesh yet
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_MEMPOOL = 4;
     */
    MEMPOOL = 4,
    /**
     * submitted to the mesh
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_MESH = 5;
     */
    MESH = 5,
    /**
     * processed by STF; check Receipt for success or failure
     *
     * @generated from protobuf enum value: TRANSACTION_STATE_PROCESSED = 6;
     */
    PROCESSED = 6
}
/**
 * TransactionResultsRequest request object for results stream.
 *
 * @generated from protobuf message spacemesh.v1.TransactionResultsRequest
 */
export interface TransactionResultsRequest {
    /**
     * id is filter by transaction id.
     *
     * @generated from protobuf field: bytes id = 1;
     */
    id: Uint8Array;
    /**
     * address is a filter by account address, it could be principal or any affected address.
     *
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * start streaming from this layer. if 0 - stream will start from genesis.
     *
     * @generated from protobuf field: uint32 start = 3;
     */
    start: number;
    /**
     * end streaming at this layer. if 0 - stream till the latest available layer.
     *
     * @generated from protobuf field: uint32 end = 4;
     */
    end: number;
    /**
     * watch live data.
     *
     * @generated from protobuf field: bool watch = 5;
     */
    watch: boolean;
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionResult
 */
export interface TransactionResult {
    /**
     * @generated from protobuf field: spacemesh.v1.Transaction tx = 1;
     */
    tx?: Transaction;
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionResult.Status status = 2;
     */
    status: TransactionResult_Status;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: uint64 gas_consumed = 4;
     */
    gasConsumed: bigint;
    /**
     * @generated from protobuf field: uint64 fee = 5;
     */
    fee: bigint;
    /**
     * @generated from protobuf field: bytes block = 6;
     */
    block: Uint8Array;
    /**
     * @generated from protobuf field: uint32 layer = 7;
     */
    layer: number;
    /**
     * @generated from protobuf field: repeated string touched_addresses = 8;
     */
    touchedAddresses: string[];
}
/**
 * @generated from protobuf enum spacemesh.v1.TransactionResult.Status
 */
export enum TransactionResult_Status {
    /**
     * @generated from protobuf enum value: SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: FAILURE = 1;
     */
    FAILURE = 1,
    /**
     * @generated from protobuf enum value: INVALID = 2;
     */
    INVALID = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsIds$Type extends MessageType<TransactionsIds> {
    constructor() {
        super("spacemesh.v1.TransactionsIds", [
            { no: 1, name: "transaction_id", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionId }
        ]);
    }
    create(value?: PartialMessage<TransactionsIds>): TransactionsIds {
        const message = { transactionId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsIds>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsIds): TransactionsIds {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.TransactionId transaction_id */ 1:
                    message.transactionId.push(TransactionId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsIds, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.TransactionId transaction_id = 1; */
        for (let i = 0; i < message.transactionId.length; i++)
            TransactionId.internalBinaryWrite(message.transactionId[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionsIds
 */
export const TransactionsIds = new TransactionsIds$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitTransactionRequest$Type extends MessageType<SubmitTransactionRequest> {
    constructor() {
        super("spacemesh.v1.SubmitTransactionRequest", [
            { no: 1, name: "transaction", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitTransactionRequest>): SubmitTransactionRequest {
        const message = { transaction: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitTransactionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitTransactionRequest): SubmitTransactionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes transaction */ 1:
                    message.transaction = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitTransactionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes transaction = 1; */
        if (message.transaction.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SubmitTransactionRequest
 */
export const SubmitTransactionRequest = new SubmitTransactionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitTransactionResponse$Type extends MessageType<SubmitTransactionResponse> {
    constructor() {
        super("spacemesh.v1.SubmitTransactionResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status },
            { no: 2, name: "txstate", kind: "message", T: () => TransactionState }
        ]);
    }
    create(value?: PartialMessage<SubmitTransactionResponse>): SubmitTransactionResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubmitTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitTransactionResponse): SubmitTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* spacemesh.v1.TransactionState txstate */ 2:
                    message.txstate = TransactionState.internalBinaryRead(reader, reader.uint32(), options, message.txstate);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionState txstate = 2; */
        if (message.txstate)
            TransactionState.internalBinaryWrite(message.txstate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SubmitTransactionResponse
 */
export const SubmitTransactionResponse = new SubmitTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsStateRequest$Type extends MessageType<TransactionsStateRequest> {
    constructor() {
        super("spacemesh.v1.TransactionsStateRequest", [
            { no: 1, name: "transaction_id", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionId },
            { no: 2, name: "include_transactions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionsStateRequest>): TransactionsStateRequest {
        const message = { transactionId: [], includeTransactions: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsStateRequest): TransactionsStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.TransactionId transaction_id */ 1:
                    message.transactionId.push(TransactionId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool include_transactions */ 2:
                    message.includeTransactions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.TransactionId transaction_id = 1; */
        for (let i = 0; i < message.transactionId.length; i++)
            TransactionId.internalBinaryWrite(message.transactionId[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool include_transactions = 2; */
        if (message.includeTransactions !== false)
            writer.tag(2, WireType.Varint).bool(message.includeTransactions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionsStateRequest
 */
export const TransactionsStateRequest = new TransactionsStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsStateResponse$Type extends MessageType<TransactionsStateResponse> {
    constructor() {
        super("spacemesh.v1.TransactionsStateResponse", [
            { no: 1, name: "transactions_state", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionState },
            { no: 2, name: "transactions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<TransactionsStateResponse>): TransactionsStateResponse {
        const message = { transactionsState: [], transactions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsStateResponse): TransactionsStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.TransactionState transactions_state */ 1:
                    message.transactionsState.push(TransactionState.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated spacemesh.v1.Transaction transactions */ 2:
                    message.transactions.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.TransactionState transactions_state = 1; */
        for (let i = 0; i < message.transactionsState.length; i++)
            TransactionState.internalBinaryWrite(message.transactionsState[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated spacemesh.v1.Transaction transactions = 2; */
        for (let i = 0; i < message.transactions.length; i++)
            Transaction.internalBinaryWrite(message.transactions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionsStateResponse
 */
export const TransactionsStateResponse = new TransactionsStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsStateStreamRequest$Type extends MessageType<TransactionsStateStreamRequest> {
    constructor() {
        super("spacemesh.v1.TransactionsStateStreamRequest", [
            { no: 1, name: "transaction_id", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TransactionId },
            { no: 2, name: "include_transactions", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionsStateStreamRequest>): TransactionsStateStreamRequest {
        const message = { transactionId: [], includeTransactions: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsStateStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsStateStreamRequest): TransactionsStateStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.TransactionId transaction_id */ 1:
                    message.transactionId.push(TransactionId.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool include_transactions */ 2:
                    message.includeTransactions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsStateStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.TransactionId transaction_id = 1; */
        for (let i = 0; i < message.transactionId.length; i++)
            TransactionId.internalBinaryWrite(message.transactionId[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool include_transactions = 2; */
        if (message.includeTransactions !== false)
            writer.tag(2, WireType.Varint).bool(message.includeTransactions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionsStateStreamRequest
 */
export const TransactionsStateStreamRequest = new TransactionsStateStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionsStateStreamResponse$Type extends MessageType<TransactionsStateStreamResponse> {
    constructor() {
        super("spacemesh.v1.TransactionsStateStreamResponse", [
            { no: 1, name: "transaction_state", kind: "message", T: () => TransactionState },
            { no: 2, name: "transaction", kind: "message", T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<TransactionsStateStreamResponse>): TransactionsStateStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionsStateStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionsStateStreamResponse): TransactionsStateStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.TransactionState transaction_state */ 1:
                    message.transactionState = TransactionState.internalBinaryRead(reader, reader.uint32(), options, message.transactionState);
                    break;
                case /* spacemesh.v1.Transaction transaction */ 2:
                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionsStateStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.TransactionState transaction_state = 1; */
        if (message.transactionState)
            TransactionState.internalBinaryWrite(message.transactionState, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Transaction transaction = 2; */
        if (message.transaction)
            Transaction.internalBinaryWrite(message.transaction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionsStateStreamResponse
 */
export const TransactionsStateStreamResponse = new TransactionsStateStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionState$Type extends MessageType<TransactionState> {
    constructor() {
        super("spacemesh.v1.TransactionState", [
            { no: 1, name: "id", kind: "message", T: () => TransactionId },
            { no: 2, name: "state", kind: "enum", T: () => ["spacemesh.v1.TransactionState.TransactionState", TransactionState_TransactionState, "TRANSACTION_STATE_"] }
        ]);
    }
    create(value?: PartialMessage<TransactionState>): TransactionState {
        const message = { state: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionState): TransactionState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.TransactionId id */ 1:
                    message.id = TransactionId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* spacemesh.v1.TransactionState.TransactionState state */ 2:
                    message.state = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.TransactionId id = 1; */
        if (message.id)
            TransactionId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionState.TransactionState state = 2; */
        if (message.state !== 0)
            writer.tag(2, WireType.Varint).int32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionState
 */
export const TransactionState = new TransactionState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionResultsRequest$Type extends MessageType<TransactionResultsRequest> {
    constructor() {
        super("spacemesh.v1.TransactionResultsRequest", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "start", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "end", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "watch", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionResultsRequest>): TransactionResultsRequest {
        const message = { id: new Uint8Array(0), address: "", start: 0, end: 0, watch: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionResultsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionResultsRequest): TransactionResultsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* uint32 start */ 3:
                    message.start = reader.uint32();
                    break;
                case /* uint32 end */ 4:
                    message.end = reader.uint32();
                    break;
                case /* bool watch */ 5:
                    message.watch = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionResultsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* uint32 start = 3; */
        if (message.start !== 0)
            writer.tag(3, WireType.Varint).uint32(message.start);
        /* uint32 end = 4; */
        if (message.end !== 0)
            writer.tag(4, WireType.Varint).uint32(message.end);
        /* bool watch = 5; */
        if (message.watch !== false)
            writer.tag(5, WireType.Varint).bool(message.watch);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionResultsRequest
 */
export const TransactionResultsRequest = new TransactionResultsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionResult$Type extends MessageType<TransactionResult> {
    constructor() {
        super("spacemesh.v1.TransactionResult", [
            { no: 1, name: "tx", kind: "message", T: () => Transaction },
            { no: 2, name: "status", kind: "enum", T: () => ["spacemesh.v1.TransactionResult.Status", TransactionResult_Status] },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "gas_consumed", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "fee", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "block", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "layer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "touched_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionResult>): TransactionResult {
        const message = { status: 0, message: "", gasConsumed: 0n, fee: 0n, block: new Uint8Array(0), layer: 0, touchedAddresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionResult): TransactionResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Transaction tx */ 1:
                    message.tx = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.tx);
                    break;
                case /* spacemesh.v1.TransactionResult.Status status */ 2:
                    message.status = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* uint64 gas_consumed */ 4:
                    message.gasConsumed = reader.uint64().toBigInt();
                    break;
                case /* uint64 fee */ 5:
                    message.fee = reader.uint64().toBigInt();
                    break;
                case /* bytes block */ 6:
                    message.block = reader.bytes();
                    break;
                case /* uint32 layer */ 7:
                    message.layer = reader.uint32();
                    break;
                case /* repeated string touched_addresses */ 8:
                    message.touchedAddresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Transaction tx = 1; */
        if (message.tx)
            Transaction.internalBinaryWrite(message.tx, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionResult.Status status = 2; */
        if (message.status !== 0)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* uint64 gas_consumed = 4; */
        if (message.gasConsumed !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.gasConsumed);
        /* uint64 fee = 5; */
        if (message.fee !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.fee);
        /* bytes block = 6; */
        if (message.block.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.block);
        /* uint32 layer = 7; */
        if (message.layer !== 0)
            writer.tag(7, WireType.Varint).uint32(message.layer);
        /* repeated string touched_addresses = 8; */
        for (let i = 0; i < message.touchedAddresses.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.touchedAddresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionResult
 */
export const TransactionResult = new TransactionResult$Type();
