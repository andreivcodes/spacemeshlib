// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/smesher_types.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Amount } from "./types";
import { SimpleInt } from "./types";
import { Status } from "../../google/rpc/status";
import { AccountId } from "./types";
/**
 * @generated from protobuf message spacemesh.v1.IsSmeshingResponse
 */
export interface IsSmeshingResponse {
    /**
     * @generated from protobuf field: bool is_smeshing = 1;
     */
    isSmeshing: boolean;
}
/**
 * @generated from protobuf message spacemesh.v1.StartSmeshingRequest
 */
export interface StartSmeshingRequest {
    /**
     * Coinbase account for rewards accumulation.
     *
     * @generated from protobuf field: spacemesh.v1.AccountId coinbase = 1;
     */
    coinbase?: AccountId;
    /**
     * The Post setup options.
     *
     * @generated from protobuf field: spacemesh.v1.PostSetupOpts opts = 2;
     */
    opts?: PostSetupOpts;
}
/**
 * @generated from protobuf message spacemesh.v1.StartSmeshingResponse
 */
export interface StartSmeshingResponse {
    /**
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
}
/**
 * Param passed to methods to indicate a request to delete data files
 *
 * @generated from protobuf message spacemesh.v1.StopSmeshingRequest
 */
export interface StopSmeshingRequest {
    /**
     * @generated from protobuf field: bool delete_files = 1;
     */
    deleteFiles: boolean;
}
/**
 * @generated from protobuf message spacemesh.v1.StopSmeshingResponse
 */
export interface StopSmeshingResponse {
    /**
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
}
/**
 * @generated from protobuf message spacemesh.v1.SetCoinbaseRequest
 */
export interface SetCoinbaseRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId id = 1;
     */
    id?: AccountId;
}
/**
 * @generated from protobuf message spacemesh.v1.SetCoinbaseResponse
 */
export interface SetCoinbaseResponse {
    /**
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
}
/**
 * @generated from protobuf message spacemesh.v1.MinGasResponse
 */
export interface MinGasResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt mingas = 1;
     */
    mingas?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.SetMinGasRequest
 */
export interface SetMinGasRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt mingas = 1;
     */
    mingas?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.SetMinGasResponse
 */
export interface SetMinGasResponse {
    /**
     * @generated from protobuf field: google.rpc.Status status = 1;
     */
    status?: Status;
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherIDResponse
 */
export interface SmesherIDResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId;
}
/**
 * @generated from protobuf message spacemesh.v1.CoinbaseResponse
 */
export interface CoinbaseResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId;
}
/**
 * @generated from protobuf message spacemesh.v1.EstimatedRewardsRequest
 */
export interface EstimatedRewardsRequest {
}
/**
 * Estimated rewards for the next epoch. Note that this is a global value that will be the
 * same for all smeshers, and is based on the default minimum commitment size and fixed
 * epoch length, both of which are network params.
 *
 * @generated from protobuf message spacemesh.v1.EstimatedRewardsResponse
 */
export interface EstimatedRewardsResponse {
    /**
     * The amount of the total estimated reward in the next upcoming epoch
     *
     * @generated from protobuf field: spacemesh.v1.Amount amount = 1;
     */
    amount?: Amount;
    /**
     * The number of Post data commitment units that this estimated reward corresponds to (part of global config)
     *
     * @generated from protobuf field: uint32 num_units = 2;
     */
    numUnits: number;
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupComputeProvidersRequest
 */
export interface PostSetupComputeProvidersRequest {
    /**
     * Whether to run a short benchmarking session for each provider to evaluate its performance
     *
     * @generated from protobuf field: bool benchmark = 1;
     */
    benchmark: boolean;
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupComputeProvidersResponse
 */
export interface PostSetupComputeProvidersResponse {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.PostSetupComputeProvider providers = 1;
     */
    providers: PostSetupComputeProvider[];
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupStatusResponse
 */
export interface PostSetupStatusResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.PostSetupStatus status = 1;
     */
    status?: PostSetupStatus;
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupStatusStreamResponse
 */
export interface PostSetupStatusStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.PostSetupStatus status = 1;
     */
    status?: PostSetupStatus;
}
/**
 * @generated from protobuf message spacemesh.v1.PostConfigResponse
 */
export interface PostConfigResponse {
    /**
     * @generated from protobuf field: uint32 bits_per_label = 1;
     */
    bitsPerLabel: number;
    /**
     * @generated from protobuf field: uint64 labels_per_unit = 2;
     */
    labelsPerUnit: bigint;
    /**
     * @generated from protobuf field: uint32 min_num_units = 3;
     */
    minNumUnits: number;
    /**
     * @generated from protobuf field: uint32 max_num_units = 4;
     */
    maxNumUnits: number;
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupComputeProvider
 */
export interface PostSetupComputeProvider {
    /**
     * @generated from protobuf field: uint32 id = 1;
     */
    id: number; // 0, 1, 2...
    /**
     * @generated from protobuf field: string model = 2;
     */
    model: string; // e.g. Nvidia GTX 2700
    /**
     * @generated from protobuf field: spacemesh.v1.PostSetupComputeProvider.ComputeApiClass compute_api = 3;
     */
    computeApi: PostSetupComputeProvider_ComputeApiClass; // A provided compute api
    /**
     * @generated from protobuf field: uint64 performance = 4;
     */
    performance: bigint; // Estimated performance in hashes per second
}
/**
 * @generated from protobuf enum spacemesh.v1.PostSetupComputeProvider.ComputeApiClass
 */
export enum PostSetupComputeProvider_ComputeApiClass {
    /**
     * @generated from protobuf enum value: COMPUTE_API_CLASS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * useful for testing on systems without a cuda or vulkan GPU
     *
     * @generated from protobuf enum value: COMPUTE_API_CLASS_CPU = 1;
     */
    CPU = 1,
    /**
     * @generated from protobuf enum value: COMPUTE_API_CLASS_CUDA = 2;
     */
    CUDA = 2,
    /**
     * @generated from protobuf enum value: COMPUTE_API_CLASS_VULKAN = 3;
     */
    VULKAN = 3
}
/**
 * Post setup options, used to define the setup requirements.
 *
 * @generated from protobuf message spacemesh.v1.PostSetupOpts
 */
export interface PostSetupOpts {
    /**
     * @generated from protobuf field: string data_dir = 1;
     */
    dataDir: string; // User provided path to create the setup data files at
    /**
     * @generated from protobuf field: uint32 num_units = 2;
     */
    numUnits: number; // Number of Post data units to generate
    /**
     * @generated from protobuf field: uint32 num_files = 3;
     */
    numFiles: number; // Number of files to equally distribute the data among
    /**
     * @generated from protobuf field: uint32 compute_provider_id = 4;
     */
    computeProviderId: number; // A `PostSetupComputeProvider` id
    /**
     * @generated from protobuf field: bool throttle = 5;
     */
    throttle: boolean; // Throttle down setup phase computations while user is interactive on system
}
/**
 * @generated from protobuf message spacemesh.v1.PostSetupStatus
 */
export interface PostSetupStatus {
    /**
     * @generated from protobuf field: spacemesh.v1.PostSetupStatus.State state = 1;
     */
    state: PostSetupStatus_State;
    /**
     * @generated from protobuf field: uint64 num_labels_written = 2;
     */
    numLabelsWritten: bigint; // Number of labels (hashes) written to the data files
    /**
     * @generated from protobuf field: spacemesh.v1.PostSetupOpts opts = 3;
     */
    opts?: PostSetupOpts; // setup options previously set by the user
    /**
     * @generated from protobuf field: string error_message = 4;
     */
    errorMessage: string; // The error message, if the state is STATE_ERROR
}
/**
 * @generated from protobuf enum spacemesh.v1.PostSetupStatus.State
 */
export enum PostSetupStatus_State {
    /**
     * Lane's favorite impossible value
     *
     * @generated from protobuf enum value: STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Setup not started
     *
     * @generated from protobuf enum value: STATE_NOT_STARTED = 1;
     */
    NOT_STARTED = 1,
    /**
     * Setup in progress
     *
     * @generated from protobuf enum value: STATE_IN_PROGRESS = 2;
     */
    IN_PROGRESS = 2,
    /**
     * Setup is complete
     *
     * @generated from protobuf enum value: STATE_COMPLETE = 3;
     */
    COMPLETE = 3,
    /**
     * Setup last session ended with an error
     *
     * @generated from protobuf enum value: STATE_ERROR = 4;
     */
    ERROR = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class IsSmeshingResponse$Type extends MessageType<IsSmeshingResponse> {
    constructor() {
        super("spacemesh.v1.IsSmeshingResponse", [
            { no: 1, name: "is_smeshing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<IsSmeshingResponse>): IsSmeshingResponse {
        const message = { isSmeshing: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IsSmeshingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IsSmeshingResponse): IsSmeshingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_smeshing */ 1:
                    message.isSmeshing = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IsSmeshingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_smeshing = 1; */
        if (message.isSmeshing !== false)
            writer.tag(1, WireType.Varint).bool(message.isSmeshing);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.IsSmeshingResponse
 */
export const IsSmeshingResponse = new IsSmeshingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSmeshingRequest$Type extends MessageType<StartSmeshingRequest> {
    constructor() {
        super("spacemesh.v1.StartSmeshingRequest", [
            { no: 1, name: "coinbase", kind: "message", T: () => AccountId },
            { no: 2, name: "opts", kind: "message", T: () => PostSetupOpts }
        ]);
    }
    create(value?: PartialMessage<StartSmeshingRequest>): StartSmeshingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartSmeshingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSmeshingRequest): StartSmeshingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId coinbase */ 1:
                    message.coinbase = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.coinbase);
                    break;
                case /* spacemesh.v1.PostSetupOpts opts */ 2:
                    message.opts = PostSetupOpts.internalBinaryRead(reader, reader.uint32(), options, message.opts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSmeshingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId coinbase = 1; */
        if (message.coinbase)
            AccountId.internalBinaryWrite(message.coinbase, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.PostSetupOpts opts = 2; */
        if (message.opts)
            PostSetupOpts.internalBinaryWrite(message.opts, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.StartSmeshingRequest
 */
export const StartSmeshingRequest = new StartSmeshingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartSmeshingResponse$Type extends MessageType<StartSmeshingResponse> {
    constructor() {
        super("spacemesh.v1.StartSmeshingResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StartSmeshingResponse>): StartSmeshingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartSmeshingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartSmeshingResponse): StartSmeshingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartSmeshingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.StartSmeshingResponse
 */
export const StartSmeshingResponse = new StartSmeshingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopSmeshingRequest$Type extends MessageType<StopSmeshingRequest> {
    constructor() {
        super("spacemesh.v1.StopSmeshingRequest", [
            { no: 1, name: "delete_files", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StopSmeshingRequest>): StopSmeshingRequest {
        const message = { deleteFiles: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopSmeshingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopSmeshingRequest): StopSmeshingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool delete_files */ 1:
                    message.deleteFiles = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopSmeshingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool delete_files = 1; */
        if (message.deleteFiles !== false)
            writer.tag(1, WireType.Varint).bool(message.deleteFiles);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.StopSmeshingRequest
 */
export const StopSmeshingRequest = new StopSmeshingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopSmeshingResponse$Type extends MessageType<StopSmeshingResponse> {
    constructor() {
        super("spacemesh.v1.StopSmeshingResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<StopSmeshingResponse>): StopSmeshingResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopSmeshingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopSmeshingResponse): StopSmeshingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopSmeshingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.StopSmeshingResponse
 */
export const StopSmeshingResponse = new StopSmeshingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCoinbaseRequest$Type extends MessageType<SetCoinbaseRequest> {
    constructor() {
        super("spacemesh.v1.SetCoinbaseRequest", [
            { no: 1, name: "id", kind: "message", T: () => AccountId }
        ]);
    }
    create(value?: PartialMessage<SetCoinbaseRequest>): SetCoinbaseRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetCoinbaseRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCoinbaseRequest): SetCoinbaseRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId id */ 1:
                    message.id = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCoinbaseRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId id = 1; */
        if (message.id)
            AccountId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SetCoinbaseRequest
 */
export const SetCoinbaseRequest = new SetCoinbaseRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetCoinbaseResponse$Type extends MessageType<SetCoinbaseResponse> {
    constructor() {
        super("spacemesh.v1.SetCoinbaseResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<SetCoinbaseResponse>): SetCoinbaseResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetCoinbaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetCoinbaseResponse): SetCoinbaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetCoinbaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SetCoinbaseResponse
 */
export const SetCoinbaseResponse = new SetCoinbaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinGasResponse$Type extends MessageType<MinGasResponse> {
    constructor() {
        super("spacemesh.v1.MinGasResponse", [
            { no: 1, name: "mingas", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<MinGasResponse>): MinGasResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MinGasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MinGasResponse): MinGasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt mingas */ 1:
                    message.mingas = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.mingas);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MinGasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt mingas = 1; */
        if (message.mingas)
            SimpleInt.internalBinaryWrite(message.mingas, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.MinGasResponse
 */
export const MinGasResponse = new MinGasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMinGasRequest$Type extends MessageType<SetMinGasRequest> {
    constructor() {
        super("spacemesh.v1.SetMinGasRequest", [
            { no: 1, name: "mingas", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<SetMinGasRequest>): SetMinGasRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetMinGasRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMinGasRequest): SetMinGasRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt mingas */ 1:
                    message.mingas = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.mingas);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetMinGasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt mingas = 1; */
        if (message.mingas)
            SimpleInt.internalBinaryWrite(message.mingas, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SetMinGasRequest
 */
export const SetMinGasRequest = new SetMinGasRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetMinGasResponse$Type extends MessageType<SetMinGasResponse> {
    constructor() {
        super("spacemesh.v1.SetMinGasResponse", [
            { no: 1, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<SetMinGasResponse>): SetMinGasResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetMinGasResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetMinGasResponse): SetMinGasResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.rpc.Status status */ 1:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetMinGasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.rpc.Status status = 1; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SetMinGasResponse
 */
export const SetMinGasResponse = new SetMinGasResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherIDResponse$Type extends MessageType<SmesherIDResponse> {
    constructor() {
        super("spacemesh.v1.SmesherIDResponse", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId }
        ]);
    }
    create(value?: PartialMessage<SmesherIDResponse>): SmesherIDResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherIDResponse): SmesherIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherIDResponse
 */
export const SmesherIDResponse = new SmesherIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoinbaseResponse$Type extends MessageType<CoinbaseResponse> {
    constructor() {
        super("spacemesh.v1.CoinbaseResponse", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId }
        ]);
    }
    create(value?: PartialMessage<CoinbaseResponse>): CoinbaseResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoinbaseResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoinbaseResponse): CoinbaseResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoinbaseResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.CoinbaseResponse
 */
export const CoinbaseResponse = new CoinbaseResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimatedRewardsRequest$Type extends MessageType<EstimatedRewardsRequest> {
    constructor() {
        super("spacemesh.v1.EstimatedRewardsRequest", []);
    }
    create(value?: PartialMessage<EstimatedRewardsRequest>): EstimatedRewardsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimatedRewardsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimatedRewardsRequest): EstimatedRewardsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EstimatedRewardsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.EstimatedRewardsRequest
 */
export const EstimatedRewardsRequest = new EstimatedRewardsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EstimatedRewardsResponse$Type extends MessageType<EstimatedRewardsResponse> {
    constructor() {
        super("spacemesh.v1.EstimatedRewardsResponse", [
            { no: 1, name: "amount", kind: "message", T: () => Amount },
            { no: 2, name: "num_units", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EstimatedRewardsResponse>): EstimatedRewardsResponse {
        const message = { numUnits: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EstimatedRewardsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EstimatedRewardsResponse): EstimatedRewardsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Amount amount */ 1:
                    message.amount = Amount.internalBinaryRead(reader, reader.uint32(), options, message.amount);
                    break;
                case /* uint32 num_units */ 2:
                    message.numUnits = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EstimatedRewardsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Amount amount = 1; */
        if (message.amount)
            Amount.internalBinaryWrite(message.amount, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 num_units = 2; */
        if (message.numUnits !== 0)
            writer.tag(2, WireType.Varint).uint32(message.numUnits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.EstimatedRewardsResponse
 */
export const EstimatedRewardsResponse = new EstimatedRewardsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupComputeProvidersRequest$Type extends MessageType<PostSetupComputeProvidersRequest> {
    constructor() {
        super("spacemesh.v1.PostSetupComputeProvidersRequest", [
            { no: 1, name: "benchmark", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PostSetupComputeProvidersRequest>): PostSetupComputeProvidersRequest {
        const message = { benchmark: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupComputeProvidersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupComputeProvidersRequest): PostSetupComputeProvidersRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool benchmark */ 1:
                    message.benchmark = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupComputeProvidersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool benchmark = 1; */
        if (message.benchmark !== false)
            writer.tag(1, WireType.Varint).bool(message.benchmark);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupComputeProvidersRequest
 */
export const PostSetupComputeProvidersRequest = new PostSetupComputeProvidersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupComputeProvidersResponse$Type extends MessageType<PostSetupComputeProvidersResponse> {
    constructor() {
        super("spacemesh.v1.PostSetupComputeProvidersResponse", [
            { no: 1, name: "providers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PostSetupComputeProvider }
        ]);
    }
    create(value?: PartialMessage<PostSetupComputeProvidersResponse>): PostSetupComputeProvidersResponse {
        const message = { providers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupComputeProvidersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupComputeProvidersResponse): PostSetupComputeProvidersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.PostSetupComputeProvider providers */ 1:
                    message.providers.push(PostSetupComputeProvider.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupComputeProvidersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.PostSetupComputeProvider providers = 1; */
        for (let i = 0; i < message.providers.length; i++)
            PostSetupComputeProvider.internalBinaryWrite(message.providers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupComputeProvidersResponse
 */
export const PostSetupComputeProvidersResponse = new PostSetupComputeProvidersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupStatusResponse$Type extends MessageType<PostSetupStatusResponse> {
    constructor() {
        super("spacemesh.v1.PostSetupStatusResponse", [
            { no: 1, name: "status", kind: "message", T: () => PostSetupStatus }
        ]);
    }
    create(value?: PartialMessage<PostSetupStatusResponse>): PostSetupStatusResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupStatusResponse): PostSetupStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.PostSetupStatus status */ 1:
                    message.status = PostSetupStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.PostSetupStatus status = 1; */
        if (message.status)
            PostSetupStatus.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupStatusResponse
 */
export const PostSetupStatusResponse = new PostSetupStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupStatusStreamResponse$Type extends MessageType<PostSetupStatusStreamResponse> {
    constructor() {
        super("spacemesh.v1.PostSetupStatusStreamResponse", [
            { no: 1, name: "status", kind: "message", T: () => PostSetupStatus }
        ]);
    }
    create(value?: PartialMessage<PostSetupStatusStreamResponse>): PostSetupStatusStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupStatusStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupStatusStreamResponse): PostSetupStatusStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.PostSetupStatus status */ 1:
                    message.status = PostSetupStatus.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupStatusStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.PostSetupStatus status = 1; */
        if (message.status)
            PostSetupStatus.internalBinaryWrite(message.status, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupStatusStreamResponse
 */
export const PostSetupStatusStreamResponse = new PostSetupStatusStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostConfigResponse$Type extends MessageType<PostConfigResponse> {
    constructor() {
        super("spacemesh.v1.PostConfigResponse", [
            { no: 1, name: "bits_per_label", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "labels_per_unit", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "min_num_units", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "max_num_units", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PostConfigResponse>): PostConfigResponse {
        const message = { bitsPerLabel: 0, labelsPerUnit: 0n, minNumUnits: 0, maxNumUnits: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostConfigResponse): PostConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 bits_per_label */ 1:
                    message.bitsPerLabel = reader.uint32();
                    break;
                case /* uint64 labels_per_unit */ 2:
                    message.labelsPerUnit = reader.uint64().toBigInt();
                    break;
                case /* uint32 min_num_units */ 3:
                    message.minNumUnits = reader.uint32();
                    break;
                case /* uint32 max_num_units */ 4:
                    message.maxNumUnits = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 bits_per_label = 1; */
        if (message.bitsPerLabel !== 0)
            writer.tag(1, WireType.Varint).uint32(message.bitsPerLabel);
        /* uint64 labels_per_unit = 2; */
        if (message.labelsPerUnit !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.labelsPerUnit);
        /* uint32 min_num_units = 3; */
        if (message.minNumUnits !== 0)
            writer.tag(3, WireType.Varint).uint32(message.minNumUnits);
        /* uint32 max_num_units = 4; */
        if (message.maxNumUnits !== 0)
            writer.tag(4, WireType.Varint).uint32(message.maxNumUnits);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostConfigResponse
 */
export const PostConfigResponse = new PostConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupComputeProvider$Type extends MessageType<PostSetupComputeProvider> {
    constructor() {
        super("spacemesh.v1.PostSetupComputeProvider", [
            { no: 1, name: "id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "model", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "compute_api", kind: "enum", T: () => ["spacemesh.v1.PostSetupComputeProvider.ComputeApiClass", PostSetupComputeProvider_ComputeApiClass, "COMPUTE_API_CLASS_"] },
            { no: 4, name: "performance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PostSetupComputeProvider>): PostSetupComputeProvider {
        const message = { id: 0, model: "", computeApi: 0, performance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupComputeProvider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupComputeProvider): PostSetupComputeProvider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* string model */ 2:
                    message.model = reader.string();
                    break;
                case /* spacemesh.v1.PostSetupComputeProvider.ComputeApiClass compute_api */ 3:
                    message.computeApi = reader.int32();
                    break;
                case /* uint64 performance */ 4:
                    message.performance = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupComputeProvider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* string model = 2; */
        if (message.model !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.model);
        /* spacemesh.v1.PostSetupComputeProvider.ComputeApiClass compute_api = 3; */
        if (message.computeApi !== 0)
            writer.tag(3, WireType.Varint).int32(message.computeApi);
        /* uint64 performance = 4; */
        if (message.performance !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.performance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupComputeProvider
 */
export const PostSetupComputeProvider = new PostSetupComputeProvider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupOpts$Type extends MessageType<PostSetupOpts> {
    constructor() {
        super("spacemesh.v1.PostSetupOpts", [
            { no: 1, name: "data_dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "num_units", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "num_files", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "compute_provider_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "throttle", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PostSetupOpts>): PostSetupOpts {
        const message = { dataDir: "", numUnits: 0, numFiles: 0, computeProviderId: 0, throttle: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupOpts>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupOpts): PostSetupOpts {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data_dir */ 1:
                    message.dataDir = reader.string();
                    break;
                case /* uint32 num_units */ 2:
                    message.numUnits = reader.uint32();
                    break;
                case /* uint32 num_files */ 3:
                    message.numFiles = reader.uint32();
                    break;
                case /* uint32 compute_provider_id */ 4:
                    message.computeProviderId = reader.uint32();
                    break;
                case /* bool throttle */ 5:
                    message.throttle = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupOpts, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data_dir = 1; */
        if (message.dataDir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dataDir);
        /* uint32 num_units = 2; */
        if (message.numUnits !== 0)
            writer.tag(2, WireType.Varint).uint32(message.numUnits);
        /* uint32 num_files = 3; */
        if (message.numFiles !== 0)
            writer.tag(3, WireType.Varint).uint32(message.numFiles);
        /* uint32 compute_provider_id = 4; */
        if (message.computeProviderId !== 0)
            writer.tag(4, WireType.Varint).uint32(message.computeProviderId);
        /* bool throttle = 5; */
        if (message.throttle !== false)
            writer.tag(5, WireType.Varint).bool(message.throttle);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupOpts
 */
export const PostSetupOpts = new PostSetupOpts$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PostSetupStatus$Type extends MessageType<PostSetupStatus> {
    constructor() {
        super("spacemesh.v1.PostSetupStatus", [
            { no: 1, name: "state", kind: "enum", T: () => ["spacemesh.v1.PostSetupStatus.State", PostSetupStatus_State, "STATE_"] },
            { no: 2, name: "num_labels_written", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "opts", kind: "message", T: () => PostSetupOpts },
            { no: 4, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PostSetupStatus>): PostSetupStatus {
        const message = { state: 0, numLabelsWritten: 0n, errorMessage: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PostSetupStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PostSetupStatus): PostSetupStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.PostSetupStatus.State state */ 1:
                    message.state = reader.int32();
                    break;
                case /* uint64 num_labels_written */ 2:
                    message.numLabelsWritten = reader.uint64().toBigInt();
                    break;
                case /* spacemesh.v1.PostSetupOpts opts */ 3:
                    message.opts = PostSetupOpts.internalBinaryRead(reader, reader.uint32(), options, message.opts);
                    break;
                case /* string error_message */ 4:
                    message.errorMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PostSetupStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.PostSetupStatus.State state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* uint64 num_labels_written = 2; */
        if (message.numLabelsWritten !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.numLabelsWritten);
        /* spacemesh.v1.PostSetupOpts opts = 3; */
        if (message.opts)
            PostSetupOpts.internalBinaryWrite(message.opts, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string error_message = 4; */
        if (message.errorMessage !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.errorMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.PostSetupStatus
 */
export const PostSetupStatus = new PostSetupStatus$Type();
