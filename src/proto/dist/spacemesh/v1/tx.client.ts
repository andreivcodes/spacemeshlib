// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/tx.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { TransactionService } from "./tx";
import type { TransactionResult } from "./tx_types";
import type { TransactionResultsRequest } from "./tx_types";
import type { TransactionsStateStreamResponse } from "./tx_types";
import type { TransactionsStateStreamRequest } from "./tx_types";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { TransactionsStateResponse } from "./tx_types";
import type { TransactionsStateRequest } from "./tx_types";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { SubmitTransactionResponse } from "./tx_types";
import type { SubmitTransactionRequest } from "./tx_types";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Provides clients a way to submit a tx to the network for processing, and to
 * check or follow the "journey" of a tx from mempool to block inclusion to
 * mesh to STF processing. This service is separate from the Mesh and
 * GlobalState services because txs move across both.
 *
 * @generated from protobuf service spacemesh.v1.TransactionService
 */
export interface ITransactionServiceClient {
    /**
     * Submit a new tx to the node for processing. The response
     * TransactionState message contains both the txid of the new tx, as well
     * as whether or not it was admitted into the mempool.
     *
     * @generated from protobuf rpc: SubmitTransaction(spacemesh.v1.SubmitTransactionRequest) returns (spacemesh.v1.SubmitTransactionResponse);
     */
    submitTransaction(input: SubmitTransactionRequest, options?: RpcOptions): UnaryCall<SubmitTransactionRequest, SubmitTransactionResponse>;
    /**
     * Returns current tx state for one or more txs which indicates if a tx is
     * on the mesh, on its way to the mesh or was rejected and will never get
     * to the mesh
     *
     * @generated from protobuf rpc: TransactionsState(spacemesh.v1.TransactionsStateRequest) returns (spacemesh.v1.TransactionsStateResponse);
     */
    transactionsState(input: TransactionsStateRequest, options?: RpcOptions): UnaryCall<TransactionsStateRequest, TransactionsStateResponse>;
    // //////// Streams
    // Streams return live, new data as it becomes available to the node and
    // not historical data.

    /**
     * Returns tx state for one or more txs every time the tx state changes for
     * one of these txs
     *
     * @generated from protobuf rpc: TransactionsStateStream(spacemesh.v1.TransactionsStateStreamRequest) returns (stream spacemesh.v1.TransactionsStateStreamResponse);
     */
    transactionsStateStream(input: TransactionsStateStreamRequest, options?: RpcOptions): ServerStreamingCall<TransactionsStateStreamRequest, TransactionsStateStreamResponse>;
    /**
     * StreamResults streams historical data and watch live events with transaction results.
     *
     * @generated from protobuf rpc: StreamResults(spacemesh.v1.TransactionResultsRequest) returns (stream spacemesh.v1.TransactionResult);
     */
    streamResults(input: TransactionResultsRequest, options?: RpcOptions): ServerStreamingCall<TransactionResultsRequest, TransactionResult>;
}
/**
 * Provides clients a way to submit a tx to the network for processing, and to
 * check or follow the "journey" of a tx from mempool to block inclusion to
 * mesh to STF processing. This service is separate from the Mesh and
 * GlobalState services because txs move across both.
 *
 * @generated from protobuf service spacemesh.v1.TransactionService
 */
export class TransactionServiceClient implements ITransactionServiceClient, ServiceInfo {
    typeName = TransactionService.typeName;
    methods = TransactionService.methods;
    options = TransactionService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Submit a new tx to the node for processing. The response
     * TransactionState message contains both the txid of the new tx, as well
     * as whether or not it was admitted into the mempool.
     *
     * @generated from protobuf rpc: SubmitTransaction(spacemesh.v1.SubmitTransactionRequest) returns (spacemesh.v1.SubmitTransactionResponse);
     */
    submitTransaction(input: SubmitTransactionRequest, options?: RpcOptions): UnaryCall<SubmitTransactionRequest, SubmitTransactionResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<SubmitTransactionRequest, SubmitTransactionResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Returns current tx state for one or more txs which indicates if a tx is
     * on the mesh, on its way to the mesh or was rejected and will never get
     * to the mesh
     *
     * @generated from protobuf rpc: TransactionsState(spacemesh.v1.TransactionsStateRequest) returns (spacemesh.v1.TransactionsStateResponse);
     */
    transactionsState(input: TransactionsStateRequest, options?: RpcOptions): UnaryCall<TransactionsStateRequest, TransactionsStateResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransactionsStateRequest, TransactionsStateResponse>("unary", this._transport, method, opt, input);
    }
    // //////// Streams
    // Streams return live, new data as it becomes available to the node and
    // not historical data.

    /**
     * Returns tx state for one or more txs every time the tx state changes for
     * one of these txs
     *
     * @generated from protobuf rpc: TransactionsStateStream(spacemesh.v1.TransactionsStateStreamRequest) returns (stream spacemesh.v1.TransactionsStateStreamResponse);
     */
    transactionsStateStream(input: TransactionsStateStreamRequest, options?: RpcOptions): ServerStreamingCall<TransactionsStateStreamRequest, TransactionsStateStreamResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransactionsStateStreamRequest, TransactionsStateStreamResponse>("serverStreaming", this._transport, method, opt, input);
    }
    /**
     * StreamResults streams historical data and watch live events with transaction results.
     *
     * @generated from protobuf rpc: StreamResults(spacemesh.v1.TransactionResultsRequest) returns (stream spacemesh.v1.TransactionResult);
     */
    streamResults(input: TransactionResultsRequest, options?: RpcOptions): ServerStreamingCall<TransactionResultsRequest, TransactionResult> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<TransactionResultsRequest, TransactionResult>("serverStreaming", this._transport, method, opt, input);
    }
}
