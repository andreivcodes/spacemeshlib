// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/global_state_types.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AppEvent } from "./types";
import { SmesherId } from "./types";
import { Reward } from "./types";
import { LayerNumber } from "./types";
import { TransactionId } from "./types";
import { AccountId } from "./types";
import { Amount } from "./types";
/**
 * @generated from protobuf message spacemesh.v1.AccountState
 */
export interface AccountState {
    /**
     * @generated from protobuf field: uint64 counter = 1;
     */
    counter: bigint; // aka nonce
    /**
     * @generated from protobuf field: spacemesh.v1.Amount balance = 2;
     */
    balance?: Amount; // known account balance
}
/**
 * @generated from protobuf message spacemesh.v1.Account
 */
export interface Account {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId; // account public address
    /**
     * @generated from protobuf field: spacemesh.v1.AccountState state_current = 2;
     */
    stateCurrent?: AccountState; // current state
    /**
     * @generated from protobuf field: spacemesh.v1.AccountState state_projected = 3;
     */
    stateProjected?: AccountState; // projected state (includes pending txs)
}
/**
 * @generated from protobuf message spacemesh.v1.AccountRequest
 */
export interface AccountRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountResponse
 */
export interface AccountResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.Account account_wrapper = 1;
     */
    accountWrapper?: Account;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountDataFilter
 */
export interface AccountDataFilter {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId;
    /**
     * @generated from protobuf field: uint32 account_data_flags = 2;
     */
    accountDataFlags: number; // bit field of AccountDataFlag
}
/**
 * @generated from protobuf message spacemesh.v1.AccountDataStreamRequest
 */
export interface AccountDataStreamRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountDataFilter filter = 1;
     */
    filter?: AccountDataFilter;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountDataStreamResponse
 */
export interface AccountDataStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountData datum = 1;
     */
    datum?: AccountData;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountDataQueryRequest
 */
export interface AccountDataQueryRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountDataFilter filter = 1;
     */
    filter?: AccountDataFilter;
    /**
     * @generated from protobuf field: uint32 max_results = 2;
     */
    maxResults: number; // max numbers of results client would like to get
    /**
     * @generated from protobuf field: uint32 offset = 3;
     */
    offset: number; // return results from offset
}
/**
 * @generated from protobuf message spacemesh.v1.TransactionReceipt
 */
export interface TransactionReceipt {
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionId id = 1;
     */
    id?: TransactionId; // the source transaction
    /**
     * @generated from protobuf field: spacemesh.v1.TransactionReceipt.TransactionResult result = 2;
     */
    result: TransactionReceipt_TransactionResult; // tx processing result
    /**
     * @generated from protobuf field: uint64 gas_used = 3;
     */
    gasUsed: bigint; // gas units used by the transaction
    /**
     * @generated from protobuf field: spacemesh.v1.Amount fee = 4;
     */
    fee?: Amount; // transaction fee charged for the transaction (in smidge, gas_price * gas_used)
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer = 5;
     */
    layer?: LayerNumber; // the layer in which the STF processed this transaction
    /**
     * @generated from protobuf field: uint32 index = 6;
     */
    index: number; // the index of the tx in the ordered list of txs to be executed by stf in the layer.
    /**
     * @generated from protobuf field: bytes svm_data = 7;
     */
    svmData: Uint8Array; // svm binary data. Decode with svm-codec
}
/**
 * the results of STF transaction processing
 *
 * @generated from protobuf enum spacemesh.v1.TransactionReceipt.TransactionResult
 */
export enum TransactionReceipt_TransactionResult {
    /**
     * @generated from protobuf enum value: TRANSACTION_RESULT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * executed w/o error by the STF
     *
     * @generated from protobuf enum value: TRANSACTION_RESULT_EXECUTED = 1;
     */
    EXECUTED = 1,
    /**
     * unexpected transaction counter
     *
     * @generated from protobuf enum value: TRANSACTION_RESULT_BAD_COUNTER = 2;
     */
    BAD_COUNTER = 2,
    /**
     * app code exception
     *
     * @generated from protobuf enum value: TRANSACTION_RESULT_RUNTIME_EXCEPTION = 3;
     */
    RUNTIME_EXCEPTION = 3,
    /**
     * out of gas
     *
     * @generated from protobuf enum value: TRANSACTION_RESULT_INSUFFICIENT_GAS = 4;
     */
    INSUFFICIENT_GAS = 4,
    /**
     * failed due to sender's insufficient funds
     *
     * @generated from protobuf enum value: TRANSACTION_RESULT_INSUFFICIENT_FUNDS = 5;
     */
    INSUFFICIENT_FUNDS = 5
}
/**
 * All data items that touch an account: receipts for transactions from, or to
 * this account, as well as those that modify its state (e.g., token transfers).
 * Rewards here includes fees paid. Account contains counter and balance updates.
 * Note that this mixes concerns: transactions and rewards are _causes_ of a
 * change to account state; nonce and balance updates are _results_.
 *
 * @generated from protobuf message spacemesh.v1.AccountData
 */
export interface AccountData {
    /**
     * @generated from protobuf oneof: datum
     */
    datum: {
        oneofKind: "reward";
        /**
         * @generated from protobuf field: spacemesh.v1.Reward reward = 1;
         */
        reward: Reward;
    } | {
        oneofKind: "receipt";
        /**
         * @generated from protobuf field: spacemesh.v1.TransactionReceipt receipt = 2;
         */
        receipt: TransactionReceipt;
    } | {
        oneofKind: "accountWrapper";
        /**
         * @generated from protobuf field: spacemesh.v1.Account account_wrapper = 3;
         */
        accountWrapper: Account;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message spacemesh.v1.AccountDataQueryResponse
 */
export interface AccountDataQueryResponse {
    /**
     * @generated from protobuf field: uint32 total_results = 1;
     */
    totalResults: number;
    /**
     * @generated from protobuf field: repeated spacemesh.v1.AccountData account_item = 2;
     */
    accountItem: AccountData[];
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherRewardStreamRequest
 */
export interface SmesherRewardStreamRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.SmesherId id = 1;
     */
    id?: SmesherId;
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherRewardStreamResponse
 */
export interface SmesherRewardStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.Reward reward = 1;
     */
    reward?: Reward;
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherDataQueryRequest
 */
export interface SmesherDataQueryRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.SmesherId smesher_id = 1;
     */
    smesherId?: SmesherId;
    /**
     * @generated from protobuf field: uint32 max_results = 2;
     */
    maxResults: number; // max numbers of results client would like to get
    /**
     * @generated from protobuf field: uint32 offset = 3;
     */
    offset: number; // return results from offset
}
/**
 * @generated from protobuf message spacemesh.v1.SmesherDataQueryResponse
 */
export interface SmesherDataQueryResponse {
    /**
     * @generated from protobuf field: uint32 total_results = 1;
     */
    totalResults: number;
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Reward rewards = 2;
     */
    rewards: Reward[];
}
/**
 * @generated from protobuf message spacemesh.v1.GlobalStateHash
 */
export interface GlobalStateHash {
    /**
     * @generated from protobuf field: bytes root_hash = 1;
     */
    rootHash: Uint8Array;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layer = 2;
     */
    layer?: LayerNumber;
}
/**
 * For now this is empty but in future we might want to allow this to take a
 * layer number.
 *
 * @generated from protobuf message spacemesh.v1.GlobalStateHashRequest
 */
export interface GlobalStateHashRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.GlobalStateHashResponse
 */
export interface GlobalStateHashResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.GlobalStateHash response = 1;
     */
    response?: GlobalStateHash;
}
/**
 * @generated from protobuf message spacemesh.v1.GlobalStateStreamRequest
 */
export interface GlobalStateStreamRequest {
    /**
     * @generated from protobuf field: uint32 global_state_data_flags = 1;
     */
    globalStateDataFlags: number; // bit field of GlobalStateDataFlag
}
/**
 * @generated from protobuf message spacemesh.v1.GlobalStateData
 */
export interface GlobalStateData {
    /**
     * @generated from protobuf oneof: datum
     */
    datum: {
        oneofKind: "reward";
        /**
         * @generated from protobuf field: spacemesh.v1.Reward reward = 1;
         */
        reward: Reward;
    } | {
        oneofKind: "receipt";
        /**
         * @generated from protobuf field: spacemesh.v1.TransactionReceipt receipt = 2;
         */
        receipt: TransactionReceipt;
    } | {
        oneofKind: "accountWrapper";
        /**
         * @generated from protobuf field: spacemesh.v1.Account account_wrapper = 3;
         */
        accountWrapper: Account;
    } | {
        oneofKind: "globalState";
        /**
         * @generated from protobuf field: spacemesh.v1.GlobalStateHash global_state = 4;
         */
        globalState: GlobalStateHash;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message spacemesh.v1.GlobalStateStreamResponse
 */
export interface GlobalStateStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.GlobalStateData datum = 1;
     */
    datum?: GlobalStateData;
}
/**
 * @generated from protobuf message spacemesh.v1.AppEventStreamRequest
 */
export interface AppEventStreamRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.AppEventStreamResponse
 */
export interface AppEventStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.AppEvent event = 1;
     */
    event?: AppEvent;
}
/**
 * All data items that touch an account (see below note, under the associated
 * message)
 *
 * @generated from protobuf enum spacemesh.v1.AccountDataFlag
 */
export enum AccountDataFlag {
    /**
     * @generated from protobuf enum value: ACCOUNT_DATA_FLAG_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * tx receipt for a tx to or from an account
     *
     * @generated from protobuf enum value: ACCOUNT_DATA_FLAG_TRANSACTION_RECEIPT = 1;
     */
    TRANSACTION_RECEIPT = 1,
    /**
     * reward awarded to an account
     *
     * @generated from protobuf enum value: ACCOUNT_DATA_FLAG_REWARD = 2;
     */
    REWARD = 2,
    /**
     * account data changes (counter or balance)
     *
     * @generated from protobuf enum value: ACCOUNT_DATA_FLAG_ACCOUNT = 4;
     */
    ACCOUNT = 4
}
/**
 * @generated from protobuf enum spacemesh.v1.GlobalStateDataFlag
 */
export enum GlobalStateDataFlag {
    /**
     * @generated from protobuf enum value: GLOBAL_STATE_DATA_FLAG_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * tx receipt generated
     *
     * @generated from protobuf enum value: GLOBAL_STATE_DATA_FLAG_TRANSACTION_RECEIPT = 1;
     */
    TRANSACTION_RECEIPT = 1,
    /**
     * reward awarded to an account (includes fees paid)
     *
     * @generated from protobuf enum value: GLOBAL_STATE_DATA_FLAG_REWARD = 2;
     */
    REWARD = 2,
    /**
     * account data changes (counter or balance)
     *
     * @generated from protobuf enum value: GLOBAL_STATE_DATA_FLAG_ACCOUNT = 4;
     */
    ACCOUNT = 4,
    /**
     * hash of global state (i.e., state root)
     *
     * @generated from protobuf enum value: GLOBAL_STATE_DATA_FLAG_GLOBAL_STATE_HASH = 8;
     */
    GLOBAL_STATE_HASH = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class AccountState$Type extends MessageType<AccountState> {
    constructor() {
        super("spacemesh.v1.AccountState", [
            { no: 1, name: "counter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "balance", kind: "message", T: () => Amount }
        ]);
    }
    create(value?: PartialMessage<AccountState>): AccountState {
        const message = { counter: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountState>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountState): AccountState {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 counter */ 1:
                    message.counter = reader.uint64().toBigInt();
                    break;
                case /* spacemesh.v1.Amount balance */ 2:
                    message.balance = Amount.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountState, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 counter = 1; */
        if (message.counter !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.counter);
        /* spacemesh.v1.Amount balance = 2; */
        if (message.balance)
            Amount.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountState
 */
export const AccountState = new AccountState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Account$Type extends MessageType<Account> {
    constructor() {
        super("spacemesh.v1.Account", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId },
            { no: 2, name: "state_current", kind: "message", T: () => AccountState },
            { no: 3, name: "state_projected", kind: "message", T: () => AccountState }
        ]);
    }
    create(value?: PartialMessage<Account>): Account {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Account>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Account): Account {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                case /* spacemesh.v1.AccountState state_current */ 2:
                    message.stateCurrent = AccountState.internalBinaryRead(reader, reader.uint32(), options, message.stateCurrent);
                    break;
                case /* spacemesh.v1.AccountState state_projected */ 3:
                    message.stateProjected = AccountState.internalBinaryRead(reader, reader.uint32(), options, message.stateProjected);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Account, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.AccountState state_current = 2; */
        if (message.stateCurrent)
            AccountState.internalBinaryWrite(message.stateCurrent, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.AccountState state_projected = 3; */
        if (message.stateProjected)
            AccountState.internalBinaryWrite(message.stateProjected, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.Account
 */
export const Account = new Account$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountRequest$Type extends MessageType<AccountRequest> {
    constructor() {
        super("spacemesh.v1.AccountRequest", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId }
        ]);
    }
    create(value?: PartialMessage<AccountRequest>): AccountRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountRequest): AccountRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountRequest
 */
export const AccountRequest = new AccountRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountResponse$Type extends MessageType<AccountResponse> {
    constructor() {
        super("spacemesh.v1.AccountResponse", [
            { no: 1, name: "account_wrapper", kind: "message", T: () => Account }
        ]);
    }
    create(value?: PartialMessage<AccountResponse>): AccountResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountResponse): AccountResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Account account_wrapper */ 1:
                    message.accountWrapper = Account.internalBinaryRead(reader, reader.uint32(), options, message.accountWrapper);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Account account_wrapper = 1; */
        if (message.accountWrapper)
            Account.internalBinaryWrite(message.accountWrapper, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountResponse
 */
export const AccountResponse = new AccountResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDataFilter$Type extends MessageType<AccountDataFilter> {
    constructor() {
        super("spacemesh.v1.AccountDataFilter", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId },
            { no: 2, name: "account_data_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountDataFilter>): AccountDataFilter {
        const message = { accountDataFlags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountDataFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountDataFilter): AccountDataFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                case /* uint32 account_data_flags */ 2:
                    message.accountDataFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountDataFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 account_data_flags = 2; */
        if (message.accountDataFlags !== 0)
            writer.tag(2, WireType.Varint).uint32(message.accountDataFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountDataFilter
 */
export const AccountDataFilter = new AccountDataFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDataStreamRequest$Type extends MessageType<AccountDataStreamRequest> {
    constructor() {
        super("spacemesh.v1.AccountDataStreamRequest", [
            { no: 1, name: "filter", kind: "message", T: () => AccountDataFilter }
        ]);
    }
    create(value?: PartialMessage<AccountDataStreamRequest>): AccountDataStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountDataStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountDataStreamRequest): AccountDataStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountDataFilter filter */ 1:
                    message.filter = AccountDataFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountDataStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountDataFilter filter = 1; */
        if (message.filter)
            AccountDataFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountDataStreamRequest
 */
export const AccountDataStreamRequest = new AccountDataStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDataStreamResponse$Type extends MessageType<AccountDataStreamResponse> {
    constructor() {
        super("spacemesh.v1.AccountDataStreamResponse", [
            { no: 1, name: "datum", kind: "message", T: () => AccountData }
        ]);
    }
    create(value?: PartialMessage<AccountDataStreamResponse>): AccountDataStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountDataStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountDataStreamResponse): AccountDataStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountData datum */ 1:
                    message.datum = AccountData.internalBinaryRead(reader, reader.uint32(), options, message.datum);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountDataStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountData datum = 1; */
        if (message.datum)
            AccountData.internalBinaryWrite(message.datum, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountDataStreamResponse
 */
export const AccountDataStreamResponse = new AccountDataStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDataQueryRequest$Type extends MessageType<AccountDataQueryRequest> {
    constructor() {
        super("spacemesh.v1.AccountDataQueryRequest", [
            { no: 1, name: "filter", kind: "message", T: () => AccountDataFilter },
            { no: 2, name: "max_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountDataQueryRequest>): AccountDataQueryRequest {
        const message = { maxResults: 0, offset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountDataQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountDataQueryRequest): AccountDataQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountDataFilter filter */ 1:
                    message.filter = AccountDataFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* uint32 max_results */ 2:
                    message.maxResults = reader.uint32();
                    break;
                case /* uint32 offset */ 3:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountDataQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountDataFilter filter = 1; */
        if (message.filter)
            AccountDataFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 max_results = 2; */
        if (message.maxResults !== 0)
            writer.tag(2, WireType.Varint).uint32(message.maxResults);
        /* uint32 offset = 3; */
        if (message.offset !== 0)
            writer.tag(3, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountDataQueryRequest
 */
export const AccountDataQueryRequest = new AccountDataQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TransactionReceipt$Type extends MessageType<TransactionReceipt> {
    constructor() {
        super("spacemesh.v1.TransactionReceipt", [
            { no: 1, name: "id", kind: "message", T: () => TransactionId },
            { no: 2, name: "result", kind: "enum", T: () => ["spacemesh.v1.TransactionReceipt.TransactionResult", TransactionReceipt_TransactionResult, "TRANSACTION_RESULT_"] },
            { no: 3, name: "gas_used", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fee", kind: "message", T: () => Amount },
            { no: 5, name: "layer", kind: "message", T: () => LayerNumber },
            { no: 6, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "svm_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<TransactionReceipt>): TransactionReceipt {
        const message = { result: 0, gasUsed: 0n, index: 0, svmData: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TransactionReceipt>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TransactionReceipt): TransactionReceipt {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.TransactionId id */ 1:
                    message.id = TransactionId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* spacemesh.v1.TransactionReceipt.TransactionResult result */ 2:
                    message.result = reader.int32();
                    break;
                case /* uint64 gas_used */ 3:
                    message.gasUsed = reader.uint64().toBigInt();
                    break;
                case /* spacemesh.v1.Amount fee */ 4:
                    message.fee = Amount.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* spacemesh.v1.LayerNumber layer */ 5:
                    message.layer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layer);
                    break;
                case /* uint32 index */ 6:
                    message.index = reader.uint32();
                    break;
                case /* bytes svm_data */ 7:
                    message.svmData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TransactionReceipt, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.TransactionId id = 1; */
        if (message.id)
            TransactionId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionReceipt.TransactionResult result = 2; */
        if (message.result !== 0)
            writer.tag(2, WireType.Varint).int32(message.result);
        /* uint64 gas_used = 3; */
        if (message.gasUsed !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.gasUsed);
        /* spacemesh.v1.Amount fee = 4; */
        if (message.fee)
            Amount.internalBinaryWrite(message.fee, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber layer = 5; */
        if (message.layer)
            LayerNumber.internalBinaryWrite(message.layer, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 index = 6; */
        if (message.index !== 0)
            writer.tag(6, WireType.Varint).uint32(message.index);
        /* bytes svm_data = 7; */
        if (message.svmData.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.svmData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.TransactionReceipt
 */
export const TransactionReceipt = new TransactionReceipt$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountData$Type extends MessageType<AccountData> {
    constructor() {
        super("spacemesh.v1.AccountData", [
            { no: 1, name: "reward", kind: "message", oneof: "datum", T: () => Reward },
            { no: 2, name: "receipt", kind: "message", oneof: "datum", T: () => TransactionReceipt },
            { no: 3, name: "account_wrapper", kind: "message", oneof: "datum", T: () => Account }
        ]);
    }
    create(value?: PartialMessage<AccountData>): AccountData {
        const message = { datum: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountData): AccountData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Reward reward */ 1:
                    message.datum = {
                        oneofKind: "reward",
                        reward: Reward.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).reward)
                    };
                    break;
                case /* spacemesh.v1.TransactionReceipt receipt */ 2:
                    message.datum = {
                        oneofKind: "receipt",
                        receipt: TransactionReceipt.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).receipt)
                    };
                    break;
                case /* spacemesh.v1.Account account_wrapper */ 3:
                    message.datum = {
                        oneofKind: "accountWrapper",
                        accountWrapper: Account.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).accountWrapper)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Reward reward = 1; */
        if (message.datum.oneofKind === "reward")
            Reward.internalBinaryWrite(message.datum.reward, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionReceipt receipt = 2; */
        if (message.datum.oneofKind === "receipt")
            TransactionReceipt.internalBinaryWrite(message.datum.receipt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Account account_wrapper = 3; */
        if (message.datum.oneofKind === "accountWrapper")
            Account.internalBinaryWrite(message.datum.accountWrapper, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountData
 */
export const AccountData = new AccountData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountDataQueryResponse$Type extends MessageType<AccountDataQueryResponse> {
    constructor() {
        super("spacemesh.v1.AccountDataQueryResponse", [
            { no: 1, name: "total_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "account_item", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccountData }
        ]);
    }
    create(value?: PartialMessage<AccountDataQueryResponse>): AccountDataQueryResponse {
        const message = { totalResults: 0, accountItem: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountDataQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountDataQueryResponse): AccountDataQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total_results */ 1:
                    message.totalResults = reader.uint32();
                    break;
                case /* repeated spacemesh.v1.AccountData account_item */ 2:
                    message.accountItem.push(AccountData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountDataQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total_results = 1; */
        if (message.totalResults !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalResults);
        /* repeated spacemesh.v1.AccountData account_item = 2; */
        for (let i = 0; i < message.accountItem.length; i++)
            AccountData.internalBinaryWrite(message.accountItem[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountDataQueryResponse
 */
export const AccountDataQueryResponse = new AccountDataQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherRewardStreamRequest$Type extends MessageType<SmesherRewardStreamRequest> {
    constructor() {
        super("spacemesh.v1.SmesherRewardStreamRequest", [
            { no: 1, name: "id", kind: "message", T: () => SmesherId }
        ]);
    }
    create(value?: PartialMessage<SmesherRewardStreamRequest>): SmesherRewardStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherRewardStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherRewardStreamRequest): SmesherRewardStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SmesherId id */ 1:
                    message.id = SmesherId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherRewardStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SmesherId id = 1; */
        if (message.id)
            SmesherId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherRewardStreamRequest
 */
export const SmesherRewardStreamRequest = new SmesherRewardStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherRewardStreamResponse$Type extends MessageType<SmesherRewardStreamResponse> {
    constructor() {
        super("spacemesh.v1.SmesherRewardStreamResponse", [
            { no: 1, name: "reward", kind: "message", T: () => Reward }
        ]);
    }
    create(value?: PartialMessage<SmesherRewardStreamResponse>): SmesherRewardStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherRewardStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherRewardStreamResponse): SmesherRewardStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Reward reward */ 1:
                    message.reward = Reward.internalBinaryRead(reader, reader.uint32(), options, message.reward);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherRewardStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Reward reward = 1; */
        if (message.reward)
            Reward.internalBinaryWrite(message.reward, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherRewardStreamResponse
 */
export const SmesherRewardStreamResponse = new SmesherRewardStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherDataQueryRequest$Type extends MessageType<SmesherDataQueryRequest> {
    constructor() {
        super("spacemesh.v1.SmesherDataQueryRequest", [
            { no: 1, name: "smesher_id", kind: "message", T: () => SmesherId },
            { no: 2, name: "max_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SmesherDataQueryRequest>): SmesherDataQueryRequest {
        const message = { maxResults: 0, offset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherDataQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherDataQueryRequest): SmesherDataQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SmesherId smesher_id */ 1:
                    message.smesherId = SmesherId.internalBinaryRead(reader, reader.uint32(), options, message.smesherId);
                    break;
                case /* uint32 max_results */ 2:
                    message.maxResults = reader.uint32();
                    break;
                case /* uint32 offset */ 3:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherDataQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SmesherId smesher_id = 1; */
        if (message.smesherId)
            SmesherId.internalBinaryWrite(message.smesherId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 max_results = 2; */
        if (message.maxResults !== 0)
            writer.tag(2, WireType.Varint).uint32(message.maxResults);
        /* uint32 offset = 3; */
        if (message.offset !== 0)
            writer.tag(3, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherDataQueryRequest
 */
export const SmesherDataQueryRequest = new SmesherDataQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SmesherDataQueryResponse$Type extends MessageType<SmesherDataQueryResponse> {
    constructor() {
        super("spacemesh.v1.SmesherDataQueryResponse", [
            { no: 1, name: "total_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "rewards", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Reward }
        ]);
    }
    create(value?: PartialMessage<SmesherDataQueryResponse>): SmesherDataQueryResponse {
        const message = { totalResults: 0, rewards: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SmesherDataQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SmesherDataQueryResponse): SmesherDataQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 total_results */ 1:
                    message.totalResults = reader.uint32();
                    break;
                case /* repeated spacemesh.v1.Reward rewards */ 2:
                    message.rewards.push(Reward.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SmesherDataQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 total_results = 1; */
        if (message.totalResults !== 0)
            writer.tag(1, WireType.Varint).uint32(message.totalResults);
        /* repeated spacemesh.v1.Reward rewards = 2; */
        for (let i = 0; i < message.rewards.length; i++)
            Reward.internalBinaryWrite(message.rewards[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.SmesherDataQueryResponse
 */
export const SmesherDataQueryResponse = new SmesherDataQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateHash$Type extends MessageType<GlobalStateHash> {
    constructor() {
        super("spacemesh.v1.GlobalStateHash", [
            { no: 1, name: "root_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "layer", kind: "message", T: () => LayerNumber }
        ]);
    }
    create(value?: PartialMessage<GlobalStateHash>): GlobalStateHash {
        const message = { rootHash: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateHash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateHash): GlobalStateHash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes root_hash */ 1:
                    message.rootHash = reader.bytes();
                    break;
                case /* spacemesh.v1.LayerNumber layer */ 2:
                    message.layer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalStateHash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes root_hash = 1; */
        if (message.rootHash.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.rootHash);
        /* spacemesh.v1.LayerNumber layer = 2; */
        if (message.layer)
            LayerNumber.internalBinaryWrite(message.layer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateHash
 */
export const GlobalStateHash = new GlobalStateHash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateHashRequest$Type extends MessageType<GlobalStateHashRequest> {
    constructor() {
        super("spacemesh.v1.GlobalStateHashRequest", []);
    }
    create(value?: PartialMessage<GlobalStateHashRequest>): GlobalStateHashRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateHashRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateHashRequest): GlobalStateHashRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GlobalStateHashRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateHashRequest
 */
export const GlobalStateHashRequest = new GlobalStateHashRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateHashResponse$Type extends MessageType<GlobalStateHashResponse> {
    constructor() {
        super("spacemesh.v1.GlobalStateHashResponse", [
            { no: 1, name: "response", kind: "message", T: () => GlobalStateHash }
        ]);
    }
    create(value?: PartialMessage<GlobalStateHashResponse>): GlobalStateHashResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateHashResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateHashResponse): GlobalStateHashResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.GlobalStateHash response */ 1:
                    message.response = GlobalStateHash.internalBinaryRead(reader, reader.uint32(), options, message.response);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalStateHashResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.GlobalStateHash response = 1; */
        if (message.response)
            GlobalStateHash.internalBinaryWrite(message.response, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateHashResponse
 */
export const GlobalStateHashResponse = new GlobalStateHashResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateStreamRequest$Type extends MessageType<GlobalStateStreamRequest> {
    constructor() {
        super("spacemesh.v1.GlobalStateStreamRequest", [
            { no: 1, name: "global_state_data_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<GlobalStateStreamRequest>): GlobalStateStreamRequest {
        const message = { globalStateDataFlags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateStreamRequest): GlobalStateStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 global_state_data_flags */ 1:
                    message.globalStateDataFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalStateStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 global_state_data_flags = 1; */
        if (message.globalStateDataFlags !== 0)
            writer.tag(1, WireType.Varint).uint32(message.globalStateDataFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateStreamRequest
 */
export const GlobalStateStreamRequest = new GlobalStateStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateData$Type extends MessageType<GlobalStateData> {
    constructor() {
        super("spacemesh.v1.GlobalStateData", [
            { no: 1, name: "reward", kind: "message", oneof: "datum", T: () => Reward },
            { no: 2, name: "receipt", kind: "message", oneof: "datum", T: () => TransactionReceipt },
            { no: 3, name: "account_wrapper", kind: "message", oneof: "datum", T: () => Account },
            { no: 4, name: "global_state", kind: "message", oneof: "datum", T: () => GlobalStateHash }
        ]);
    }
    create(value?: PartialMessage<GlobalStateData>): GlobalStateData {
        const message = { datum: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateData): GlobalStateData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Reward reward */ 1:
                    message.datum = {
                        oneofKind: "reward",
                        reward: Reward.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).reward)
                    };
                    break;
                case /* spacemesh.v1.TransactionReceipt receipt */ 2:
                    message.datum = {
                        oneofKind: "receipt",
                        receipt: TransactionReceipt.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).receipt)
                    };
                    break;
                case /* spacemesh.v1.Account account_wrapper */ 3:
                    message.datum = {
                        oneofKind: "accountWrapper",
                        accountWrapper: Account.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).accountWrapper)
                    };
                    break;
                case /* spacemesh.v1.GlobalStateHash global_state */ 4:
                    message.datum = {
                        oneofKind: "globalState",
                        globalState: GlobalStateHash.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).globalState)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalStateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Reward reward = 1; */
        if (message.datum.oneofKind === "reward")
            Reward.internalBinaryWrite(message.datum.reward, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.TransactionReceipt receipt = 2; */
        if (message.datum.oneofKind === "receipt")
            TransactionReceipt.internalBinaryWrite(message.datum.receipt, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Account account_wrapper = 3; */
        if (message.datum.oneofKind === "accountWrapper")
            Account.internalBinaryWrite(message.datum.accountWrapper, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.GlobalStateHash global_state = 4; */
        if (message.datum.oneofKind === "globalState")
            GlobalStateHash.internalBinaryWrite(message.datum.globalState, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateData
 */
export const GlobalStateData = new GlobalStateData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GlobalStateStreamResponse$Type extends MessageType<GlobalStateStreamResponse> {
    constructor() {
        super("spacemesh.v1.GlobalStateStreamResponse", [
            { no: 1, name: "datum", kind: "message", T: () => GlobalStateData }
        ]);
    }
    create(value?: PartialMessage<GlobalStateStreamResponse>): GlobalStateStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GlobalStateStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GlobalStateStreamResponse): GlobalStateStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.GlobalStateData datum */ 1:
                    message.datum = GlobalStateData.internalBinaryRead(reader, reader.uint32(), options, message.datum);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GlobalStateStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.GlobalStateData datum = 1; */
        if (message.datum)
            GlobalStateData.internalBinaryWrite(message.datum, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GlobalStateStreamResponse
 */
export const GlobalStateStreamResponse = new GlobalStateStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEventStreamRequest$Type extends MessageType<AppEventStreamRequest> {
    constructor() {
        super("spacemesh.v1.AppEventStreamRequest", []);
    }
    create(value?: PartialMessage<AppEventStreamRequest>): AppEventStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEventStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEventStreamRequest): AppEventStreamRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AppEventStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AppEventStreamRequest
 */
export const AppEventStreamRequest = new AppEventStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AppEventStreamResponse$Type extends MessageType<AppEventStreamResponse> {
    constructor() {
        super("spacemesh.v1.AppEventStreamResponse", [
            { no: 1, name: "event", kind: "message", T: () => AppEvent }
        ]);
    }
    create(value?: PartialMessage<AppEventStreamResponse>): AppEventStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AppEventStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AppEventStreamResponse): AppEventStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AppEvent event */ 1:
                    message.event = AppEvent.internalBinaryRead(reader, reader.uint32(), options, message.event);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AppEventStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AppEvent event = 1; */
        if (message.event)
            AppEvent.internalBinaryWrite(message.event, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AppEventStreamResponse
 */
export const AppEventStreamResponse = new AppEventStreamResponse$Type();
