// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "spacemesh/v1/mesh_types.proto" (package "spacemesh.v1", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Layer } from "./types";
import { Activation } from "./types";
import { MeshTransaction } from "./types";
import { AccountId } from "./types";
import { LayerNumber } from "./types";
import { SimpleInt } from "./types";
/**
 * @generated from protobuf message spacemesh.v1.GenesisTimeRequest
 */
export interface GenesisTimeRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.GenesisTimeResponse
 */
export interface GenesisTimeResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt unixtime = 1;
     */
    unixtime?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.CurrentLayerRequest
 */
export interface CurrentLayerRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.CurrentLayerResponse
 */
export interface CurrentLayerResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber layernum = 1;
     */
    layernum?: LayerNumber;
}
/**
 * @generated from protobuf message spacemesh.v1.CurrentEpochRequest
 */
export interface CurrentEpochRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.CurrentEpochResponse
 */
export interface CurrentEpochResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt epochnum = 1;
     */
    epochnum?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.NetIDRequest
 */
export interface NetIDRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.NetIDResponse
 */
export interface NetIDResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt netid = 1;
     */
    netid?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.EpochNumLayersRequest
 */
export interface EpochNumLayersRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.EpochNumLayersResponse
 */
export interface EpochNumLayersResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt numlayers = 1;
     */
    numlayers?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.LayerDurationRequest
 */
export interface LayerDurationRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.LayerDurationResponse
 */
export interface LayerDurationResponse {
    /**
     * layer duration, in seconds
     *
     * @generated from protobuf field: spacemesh.v1.SimpleInt duration = 1;
     */
    duration?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.MaxTransactionsPerSecondRequest
 */
export interface MaxTransactionsPerSecondRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.MaxTransactionsPerSecondResponse
 */
export interface MaxTransactionsPerSecondResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.SimpleInt max_txs_per_second = 1;
     */
    maxTxsPerSecond?: SimpleInt;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshDataFilter
 */
export interface AccountMeshDataFilter {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountId account_id = 1;
     */
    accountId?: AccountId;
    /**
     * @generated from protobuf field: uint32 account_mesh_data_flags = 2;
     */
    accountMeshDataFlags: number; // A bit field of AccountMeshDataFlags
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshData
 */
export interface AccountMeshData {
    /**
     * @generated from protobuf oneof: datum
     */
    datum: {
        oneofKind: "meshTransaction";
        /**
         * @generated from protobuf field: spacemesh.v1.MeshTransaction mesh_transaction = 1;
         */
        meshTransaction: MeshTransaction;
    } | {
        oneofKind: "activation";
        /**
         * @generated from protobuf field: spacemesh.v1.Activation activation = 2;
         */
        activation: Activation;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshDataStreamRequest
 */
export interface AccountMeshDataStreamRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountMeshDataFilter filter = 1;
     */
    filter?: AccountMeshDataFilter;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshDataStreamResponse
 */
export interface AccountMeshDataStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountMeshData datum = 1;
     */
    datum?: AccountMeshData;
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshDataQueryRequest
 */
export interface AccountMeshDataQueryRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.AccountMeshDataFilter filter = 1;
     */
    filter?: AccountMeshDataFilter;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber min_layer = 2;
     */
    minLayer?: LayerNumber; // return data only from this layer or later
    /**
     * @generated from protobuf field: uint32 max_results = 3;
     */
    maxResults: number; // max number of results to return
    /**
     * @generated from protobuf field: uint32 offset = 4;
     */
    offset: number; // query offset
}
/**
 * @generated from protobuf message spacemesh.v1.AccountMeshDataQueryResponse
 */
export interface AccountMeshDataQueryResponse {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.AccountMeshData data = 1;
     */
    data: AccountMeshData[];
    /**
     * @generated from protobuf field: uint32 total_results = 2;
     */
    totalResults: number; // total number of availble results
}
/**
 * @generated from protobuf message spacemesh.v1.LayersQueryRequest
 */
export interface LayersQueryRequest {
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber start_layer = 1;
     */
    startLayer?: LayerNumber;
    /**
     * @generated from protobuf field: spacemesh.v1.LayerNumber end_layer = 2;
     */
    endLayer?: LayerNumber;
}
/**
 * @generated from protobuf message spacemesh.v1.LayersQueryResponse
 */
export interface LayersQueryResponse {
    /**
     * @generated from protobuf field: repeated spacemesh.v1.Layer layer = 1;
     */
    layer: Layer[];
}
/**
 * @generated from protobuf message spacemesh.v1.LayerStreamRequest
 */
export interface LayerStreamRequest {
}
/**
 * @generated from protobuf message spacemesh.v1.LayerStreamResponse
 */
export interface LayerStreamResponse {
    /**
     * @generated from protobuf field: spacemesh.v1.Layer layer = 1;
     */
    layer?: Layer;
}
/**
 * @generated from protobuf enum spacemesh.v1.AccountMeshDataFlag
 */
export enum AccountMeshDataFlag {
    /**
     * @generated from protobuf enum value: ACCOUNT_MESH_DATA_FLAG_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ACCOUNT_MESH_DATA_FLAG_TRANSACTIONS = 1;
     */
    TRANSACTIONS = 1,
    /**
     * @generated from protobuf enum value: ACCOUNT_MESH_DATA_FLAG_ACTIVATIONS = 2;
     */
    ACTIVATIONS = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class GenesisTimeRequest$Type extends MessageType<GenesisTimeRequest> {
    constructor() {
        super("spacemesh.v1.GenesisTimeRequest", []);
    }
    create(value?: PartialMessage<GenesisTimeRequest>): GenesisTimeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenesisTimeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenesisTimeRequest): GenesisTimeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GenesisTimeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GenesisTimeRequest
 */
export const GenesisTimeRequest = new GenesisTimeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenesisTimeResponse$Type extends MessageType<GenesisTimeResponse> {
    constructor() {
        super("spacemesh.v1.GenesisTimeResponse", [
            { no: 1, name: "unixtime", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<GenesisTimeResponse>): GenesisTimeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GenesisTimeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenesisTimeResponse): GenesisTimeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt unixtime */ 1:
                    message.unixtime = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.unixtime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenesisTimeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt unixtime = 1; */
        if (message.unixtime)
            SimpleInt.internalBinaryWrite(message.unixtime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.GenesisTimeResponse
 */
export const GenesisTimeResponse = new GenesisTimeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentLayerRequest$Type extends MessageType<CurrentLayerRequest> {
    constructor() {
        super("spacemesh.v1.CurrentLayerRequest", []);
    }
    create(value?: PartialMessage<CurrentLayerRequest>): CurrentLayerRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentLayerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentLayerRequest): CurrentLayerRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CurrentLayerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.CurrentLayerRequest
 */
export const CurrentLayerRequest = new CurrentLayerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentLayerResponse$Type extends MessageType<CurrentLayerResponse> {
    constructor() {
        super("spacemesh.v1.CurrentLayerResponse", [
            { no: 1, name: "layernum", kind: "message", T: () => LayerNumber }
        ]);
    }
    create(value?: PartialMessage<CurrentLayerResponse>): CurrentLayerResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentLayerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentLayerResponse): CurrentLayerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.LayerNumber layernum */ 1:
                    message.layernum = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.layernum);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentLayerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.LayerNumber layernum = 1; */
        if (message.layernum)
            LayerNumber.internalBinaryWrite(message.layernum, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.CurrentLayerResponse
 */
export const CurrentLayerResponse = new CurrentLayerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentEpochRequest$Type extends MessageType<CurrentEpochRequest> {
    constructor() {
        super("spacemesh.v1.CurrentEpochRequest", []);
    }
    create(value?: PartialMessage<CurrentEpochRequest>): CurrentEpochRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentEpochRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentEpochRequest): CurrentEpochRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CurrentEpochRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.CurrentEpochRequest
 */
export const CurrentEpochRequest = new CurrentEpochRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrentEpochResponse$Type extends MessageType<CurrentEpochResponse> {
    constructor() {
        super("spacemesh.v1.CurrentEpochResponse", [
            { no: 1, name: "epochnum", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<CurrentEpochResponse>): CurrentEpochResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrentEpochResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrentEpochResponse): CurrentEpochResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt epochnum */ 1:
                    message.epochnum = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.epochnum);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrentEpochResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt epochnum = 1; */
        if (message.epochnum)
            SimpleInt.internalBinaryWrite(message.epochnum, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.CurrentEpochResponse
 */
export const CurrentEpochResponse = new CurrentEpochResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetIDRequest$Type extends MessageType<NetIDRequest> {
    constructor() {
        super("spacemesh.v1.NetIDRequest", []);
    }
    create(value?: PartialMessage<NetIDRequest>): NetIDRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetIDRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetIDRequest): NetIDRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NetIDRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.NetIDRequest
 */
export const NetIDRequest = new NetIDRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NetIDResponse$Type extends MessageType<NetIDResponse> {
    constructor() {
        super("spacemesh.v1.NetIDResponse", [
            { no: 1, name: "netid", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<NetIDResponse>): NetIDResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NetIDResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NetIDResponse): NetIDResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt netid */ 1:
                    message.netid = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.netid);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NetIDResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt netid = 1; */
        if (message.netid)
            SimpleInt.internalBinaryWrite(message.netid, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.NetIDResponse
 */
export const NetIDResponse = new NetIDResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochNumLayersRequest$Type extends MessageType<EpochNumLayersRequest> {
    constructor() {
        super("spacemesh.v1.EpochNumLayersRequest", []);
    }
    create(value?: PartialMessage<EpochNumLayersRequest>): EpochNumLayersRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpochNumLayersRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochNumLayersRequest): EpochNumLayersRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EpochNumLayersRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.EpochNumLayersRequest
 */
export const EpochNumLayersRequest = new EpochNumLayersRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpochNumLayersResponse$Type extends MessageType<EpochNumLayersResponse> {
    constructor() {
        super("spacemesh.v1.EpochNumLayersResponse", [
            { no: 1, name: "numlayers", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<EpochNumLayersResponse>): EpochNumLayersResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpochNumLayersResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpochNumLayersResponse): EpochNumLayersResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt numlayers */ 1:
                    message.numlayers = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.numlayers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpochNumLayersResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt numlayers = 1; */
        if (message.numlayers)
            SimpleInt.internalBinaryWrite(message.numlayers, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.EpochNumLayersResponse
 */
export const EpochNumLayersResponse = new EpochNumLayersResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerDurationRequest$Type extends MessageType<LayerDurationRequest> {
    constructor() {
        super("spacemesh.v1.LayerDurationRequest", []);
    }
    create(value?: PartialMessage<LayerDurationRequest>): LayerDurationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerDurationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerDurationRequest): LayerDurationRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LayerDurationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerDurationRequest
 */
export const LayerDurationRequest = new LayerDurationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerDurationResponse$Type extends MessageType<LayerDurationResponse> {
    constructor() {
        super("spacemesh.v1.LayerDurationResponse", [
            { no: 1, name: "duration", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<LayerDurationResponse>): LayerDurationResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerDurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerDurationResponse): LayerDurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt duration */ 1:
                    message.duration = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.duration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayerDurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt duration = 1; */
        if (message.duration)
            SimpleInt.internalBinaryWrite(message.duration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerDurationResponse
 */
export const LayerDurationResponse = new LayerDurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaxTransactionsPerSecondRequest$Type extends MessageType<MaxTransactionsPerSecondRequest> {
    constructor() {
        super("spacemesh.v1.MaxTransactionsPerSecondRequest", []);
    }
    create(value?: PartialMessage<MaxTransactionsPerSecondRequest>): MaxTransactionsPerSecondRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaxTransactionsPerSecondRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxTransactionsPerSecondRequest): MaxTransactionsPerSecondRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MaxTransactionsPerSecondRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.MaxTransactionsPerSecondRequest
 */
export const MaxTransactionsPerSecondRequest = new MaxTransactionsPerSecondRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MaxTransactionsPerSecondResponse$Type extends MessageType<MaxTransactionsPerSecondResponse> {
    constructor() {
        super("spacemesh.v1.MaxTransactionsPerSecondResponse", [
            { no: 1, name: "max_txs_per_second", kind: "message", T: () => SimpleInt }
        ]);
    }
    create(value?: PartialMessage<MaxTransactionsPerSecondResponse>): MaxTransactionsPerSecondResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MaxTransactionsPerSecondResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MaxTransactionsPerSecondResponse): MaxTransactionsPerSecondResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.SimpleInt max_txs_per_second */ 1:
                    message.maxTxsPerSecond = SimpleInt.internalBinaryRead(reader, reader.uint32(), options, message.maxTxsPerSecond);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MaxTransactionsPerSecondResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.SimpleInt max_txs_per_second = 1; */
        if (message.maxTxsPerSecond)
            SimpleInt.internalBinaryWrite(message.maxTxsPerSecond, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.MaxTransactionsPerSecondResponse
 */
export const MaxTransactionsPerSecondResponse = new MaxTransactionsPerSecondResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshDataFilter$Type extends MessageType<AccountMeshDataFilter> {
    constructor() {
        super("spacemesh.v1.AccountMeshDataFilter", [
            { no: 1, name: "account_id", kind: "message", T: () => AccountId },
            { no: 2, name: "account_mesh_data_flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountMeshDataFilter>): AccountMeshDataFilter {
        const message = { accountMeshDataFlags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshDataFilter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshDataFilter): AccountMeshDataFilter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountId account_id */ 1:
                    message.accountId = AccountId.internalBinaryRead(reader, reader.uint32(), options, message.accountId);
                    break;
                case /* uint32 account_mesh_data_flags */ 2:
                    message.accountMeshDataFlags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshDataFilter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountId account_id = 1; */
        if (message.accountId)
            AccountId.internalBinaryWrite(message.accountId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 account_mesh_data_flags = 2; */
        if (message.accountMeshDataFlags !== 0)
            writer.tag(2, WireType.Varint).uint32(message.accountMeshDataFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshDataFilter
 */
export const AccountMeshDataFilter = new AccountMeshDataFilter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshData$Type extends MessageType<AccountMeshData> {
    constructor() {
        super("spacemesh.v1.AccountMeshData", [
            { no: 1, name: "mesh_transaction", kind: "message", oneof: "datum", T: () => MeshTransaction },
            { no: 2, name: "activation", kind: "message", oneof: "datum", T: () => Activation }
        ]);
    }
    create(value?: PartialMessage<AccountMeshData>): AccountMeshData {
        const message = { datum: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshData): AccountMeshData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.MeshTransaction mesh_transaction */ 1:
                    message.datum = {
                        oneofKind: "meshTransaction",
                        meshTransaction: MeshTransaction.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).meshTransaction)
                    };
                    break;
                case /* spacemesh.v1.Activation activation */ 2:
                    message.datum = {
                        oneofKind: "activation",
                        activation: Activation.internalBinaryRead(reader, reader.uint32(), options, (message.datum as any).activation)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.MeshTransaction mesh_transaction = 1; */
        if (message.datum.oneofKind === "meshTransaction")
            MeshTransaction.internalBinaryWrite(message.datum.meshTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.Activation activation = 2; */
        if (message.datum.oneofKind === "activation")
            Activation.internalBinaryWrite(message.datum.activation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshData
 */
export const AccountMeshData = new AccountMeshData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshDataStreamRequest$Type extends MessageType<AccountMeshDataStreamRequest> {
    constructor() {
        super("spacemesh.v1.AccountMeshDataStreamRequest", [
            { no: 1, name: "filter", kind: "message", T: () => AccountMeshDataFilter }
        ]);
    }
    create(value?: PartialMessage<AccountMeshDataStreamRequest>): AccountMeshDataStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshDataStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshDataStreamRequest): AccountMeshDataStreamRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountMeshDataFilter filter */ 1:
                    message.filter = AccountMeshDataFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshDataStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountMeshDataFilter filter = 1; */
        if (message.filter)
            AccountMeshDataFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshDataStreamRequest
 */
export const AccountMeshDataStreamRequest = new AccountMeshDataStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshDataStreamResponse$Type extends MessageType<AccountMeshDataStreamResponse> {
    constructor() {
        super("spacemesh.v1.AccountMeshDataStreamResponse", [
            { no: 1, name: "datum", kind: "message", T: () => AccountMeshData }
        ]);
    }
    create(value?: PartialMessage<AccountMeshDataStreamResponse>): AccountMeshDataStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshDataStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshDataStreamResponse): AccountMeshDataStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountMeshData datum */ 1:
                    message.datum = AccountMeshData.internalBinaryRead(reader, reader.uint32(), options, message.datum);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshDataStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountMeshData datum = 1; */
        if (message.datum)
            AccountMeshData.internalBinaryWrite(message.datum, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshDataStreamResponse
 */
export const AccountMeshDataStreamResponse = new AccountMeshDataStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshDataQueryRequest$Type extends MessageType<AccountMeshDataQueryRequest> {
    constructor() {
        super("spacemesh.v1.AccountMeshDataQueryRequest", [
            { no: 1, name: "filter", kind: "message", T: () => AccountMeshDataFilter },
            { no: 2, name: "min_layer", kind: "message", T: () => LayerNumber },
            { no: 3, name: "max_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "offset", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountMeshDataQueryRequest>): AccountMeshDataQueryRequest {
        const message = { maxResults: 0, offset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshDataQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshDataQueryRequest): AccountMeshDataQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.AccountMeshDataFilter filter */ 1:
                    message.filter = AccountMeshDataFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* spacemesh.v1.LayerNumber min_layer */ 2:
                    message.minLayer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.minLayer);
                    break;
                case /* uint32 max_results */ 3:
                    message.maxResults = reader.uint32();
                    break;
                case /* uint32 offset */ 4:
                    message.offset = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshDataQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.AccountMeshDataFilter filter = 1; */
        if (message.filter)
            AccountMeshDataFilter.internalBinaryWrite(message.filter, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber min_layer = 2; */
        if (message.minLayer)
            LayerNumber.internalBinaryWrite(message.minLayer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 max_results = 3; */
        if (message.maxResults !== 0)
            writer.tag(3, WireType.Varint).uint32(message.maxResults);
        /* uint32 offset = 4; */
        if (message.offset !== 0)
            writer.tag(4, WireType.Varint).uint32(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshDataQueryRequest
 */
export const AccountMeshDataQueryRequest = new AccountMeshDataQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccountMeshDataQueryResponse$Type extends MessageType<AccountMeshDataQueryResponse> {
    constructor() {
        super("spacemesh.v1.AccountMeshDataQueryResponse", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccountMeshData },
            { no: 2, name: "total_results", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountMeshDataQueryResponse>): AccountMeshDataQueryResponse {
        const message = { data: [], totalResults: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountMeshDataQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountMeshDataQueryResponse): AccountMeshDataQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.AccountMeshData data */ 1:
                    message.data.push(AccountMeshData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 total_results */ 2:
                    message.totalResults = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountMeshDataQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.AccountMeshData data = 1; */
        for (let i = 0; i < message.data.length; i++)
            AccountMeshData.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 total_results = 2; */
        if (message.totalResults !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalResults);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.AccountMeshDataQueryResponse
 */
export const AccountMeshDataQueryResponse = new AccountMeshDataQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayersQueryRequest$Type extends MessageType<LayersQueryRequest> {
    constructor() {
        super("spacemesh.v1.LayersQueryRequest", [
            { no: 1, name: "start_layer", kind: "message", T: () => LayerNumber },
            { no: 2, name: "end_layer", kind: "message", T: () => LayerNumber }
        ]);
    }
    create(value?: PartialMessage<LayersQueryRequest>): LayersQueryRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayersQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayersQueryRequest): LayersQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.LayerNumber start_layer */ 1:
                    message.startLayer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.startLayer);
                    break;
                case /* spacemesh.v1.LayerNumber end_layer */ 2:
                    message.endLayer = LayerNumber.internalBinaryRead(reader, reader.uint32(), options, message.endLayer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayersQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.LayerNumber start_layer = 1; */
        if (message.startLayer)
            LayerNumber.internalBinaryWrite(message.startLayer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* spacemesh.v1.LayerNumber end_layer = 2; */
        if (message.endLayer)
            LayerNumber.internalBinaryWrite(message.endLayer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayersQueryRequest
 */
export const LayersQueryRequest = new LayersQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayersQueryResponse$Type extends MessageType<LayersQueryResponse> {
    constructor() {
        super("spacemesh.v1.LayersQueryResponse", [
            { no: 1, name: "layer", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Layer }
        ]);
    }
    create(value?: PartialMessage<LayersQueryResponse>): LayersQueryResponse {
        const message = { layer: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayersQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayersQueryResponse): LayersQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated spacemesh.v1.Layer layer */ 1:
                    message.layer.push(Layer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayersQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated spacemesh.v1.Layer layer = 1; */
        for (let i = 0; i < message.layer.length; i++)
            Layer.internalBinaryWrite(message.layer[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayersQueryResponse
 */
export const LayersQueryResponse = new LayersQueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerStreamRequest$Type extends MessageType<LayerStreamRequest> {
    constructor() {
        super("spacemesh.v1.LayerStreamRequest", []);
    }
    create(value?: PartialMessage<LayerStreamRequest>): LayerStreamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerStreamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerStreamRequest): LayerStreamRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LayerStreamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerStreamRequest
 */
export const LayerStreamRequest = new LayerStreamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LayerStreamResponse$Type extends MessageType<LayerStreamResponse> {
    constructor() {
        super("spacemesh.v1.LayerStreamResponse", [
            { no: 1, name: "layer", kind: "message", T: () => Layer }
        ]);
    }
    create(value?: PartialMessage<LayerStreamResponse>): LayerStreamResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LayerStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LayerStreamResponse): LayerStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* spacemesh.v1.Layer layer */ 1:
                    message.layer = Layer.internalBinaryRead(reader, reader.uint32(), options, message.layer);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LayerStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* spacemesh.v1.Layer layer = 1; */
        if (message.layer)
            Layer.internalBinaryWrite(message.layer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message spacemesh.v1.LayerStreamResponse
 */
export const LayerStreamResponse = new LayerStreamResponse$Type();
